<!DOCTYPE html>
<html lang="zh-CN">
    <head hexo-theme='https://github.com/volantis-x/hexo-theme-volantis/#5.8.0'>
  <meta name="generator" content="Hexo 7.3.0">
  <meta name="Volantis" content="5.8.0">
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
  <link rel="canonical" href="http://Jav1ki4N.github.io/2024/06/14/stm32 spl based note by ian javík/"/>
  <!-- 渲染优化 -->
    <meta http-equiv='x-dns-prefetch-control' content='on' />
      <link rel='dns-prefetch' href='https://unpkg.com'>
      <link rel="preconnect" href="https://unpkg.com" crossorigin>
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Content-Security-Policy" content=" default-src 'self' https:; block-all-mixed-content; base-uri 'self' https:; form-action 'self' https:; worker-src 'self' https:; connect-src 'self' https: *; img-src 'self' data: https: *; media-src 'self' https: *; font-src 'self' data: https: *; frame-src 'self' https: *; manifest-src 'self' https: *; child-src https:; script-src 'self' https: 'unsafe-inline' *; style-src 'self' https: 'unsafe-inline' *; ">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta content="black-translucent" name="apple-mobile-web-app-status-bar-style">
  <meta content="telephone=no" name="format-detection">
  <!-- import head_begin begin -->
  <!-- import head_begin end -->
  <!-- Custom Files headBegin begin-->
  
  <!-- Custom Files headBegin end-->
  <!-- front-matter head_begin begin -->
  <!-- front-matter head_begin end -->
  <link rel="preload" href="/css/style.css" as="style">
  <link rel="preload" href="https://unpkg.com/volantis-static@0.0.1654736714924/media/fonts/VarelaRound/VarelaRound-Regular.ttf" as="font" type="font/ttf" crossorigin="anonymous">
<link rel="preload" href="https://unpkg.com/volantis-static@0.0.1654736714924/media/fonts/UbuntuMono/UbuntuMono-Regular.ttf" as="font" type="font/ttf" crossorigin="anonymous">

  <!-- feed -->
  <!-- 页面元数据 -->
  <title>STM32 SPL Based Note By Ian Javík - i4N's Terminal</title>
  <meta name="keywords" content="null">
  <meta desc name="description" content="666 - i4N - i4N's Terminal">
  
<meta property="og:type" content="article">
<meta property="og:title" content="STM32 SPL Based Note By Ian Javík">
<meta property="og:url" content="http://jav1ki4n.github.io/2024/06/14/STM32%20SPL%20Based%20Note%20By%20Ian%20Jav%C3%ADk/index.html">
<meta property="og:site_name" content="i4N&#39;s Terminal">
<meta property="og:description" content="1. STM32F103C8T6 最小系统版1.1 SWD 调试接口：下载SWD（Serial Wire Debug，串行总线调试）接口通常用于调试和编程.    引脚 描述 对应ST-LINK V2引脚    SWCLK (Serial Wire Clock) SWD时钟线 SWCLK   SWDIO (Serial Wire Debug I&#x2F;O) SWD数据线，可能标记为SWIO S">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png">
<meta property="article:published_time" content="2024-06-13T16:00:00.000Z">
<meta property="article:modified_time" content="2025-09-04T04:47:03.973Z">
<meta property="article:author" content="i4N">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png">
  <style>
    /* 首屏样式 */
    #safearea {
  display: none;
}
:root {
  --color-site-body: #f4f4f4;
  --color-site-bg: #f4f4f4;
  --color-site-inner: #fff;
  --color-site-footer: #666;
  --color-card: #fff;
  --color-text: #444;
  --color-block: #f6f6f6;
  --color-inlinecode: #c74f00;
  --color-codeblock: #fff7ea;
  --color-h1: #3a3a3a;
  --color-h2: #3a3a3a;
  --color-h3: #333;
  --color-h4: #444;
  --color-h5: #555;
  --color-h6: #666;
  --color-p: #444;
  --color-list: #666;
  --color-list-hl: #30ad91;
  --color-meta: #888;
  --color-read-bkg: #e0d8c8;
  --color-read-post: #f8f1e2;
  --color-copyright-bkg: #f5f5f5;
}
* {
  box-sizing: border-box;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  outline: none;
  margin: 0;
  padding: 0;
}
*::-webkit-scrollbar {
  height: 4px;
  width: 4px;
}
*::-webkit-scrollbar-track-piece {
  background: transparent;
}
*::-webkit-scrollbar-thumb {
  background: #3dd9b6;
  cursor: pointer;
  border-radius: 2px;
  -webkit-border-radius: 2px;
}
*::-webkit-scrollbar-thumb:hover {
  background: #ff5722;
}
html {
  color: var(--color-text);
  width: 100%;
  height: 100%;
  font-family: UbuntuMono, "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Menlo, Monaco, monospace, sans-serif;
  font-size: 16px;
}
html >::-webkit-scrollbar {
  height: 4px;
  width: 4px;
}
html >::-webkit-scrollbar-track-piece {
  background: transparent;
}
html >::-webkit-scrollbar-thumb {
  background: #54b5a0 linear-gradient(45deg, rgba(255,255,255,0.4) 25%, transparent 25%, transparent 50%, rgba(255,255,255,0.4) 50%, rgba(255,255,255,0.4) 75%, transparent 75%, transparent);
  cursor: pointer;
  border-radius: 2px;
  -webkit-border-radius: 2px;
}
html >::-webkit-scrollbar-thumb:hover {
  background: #54b5a0 linear-gradient(45deg, rgba(255,255,255,0.4) 25%, transparent 25%, transparent 50%, rgba(255,255,255,0.4) 50%, rgba(255,255,255,0.4) 75%, transparent 75%, transparent);
}
body {
  background-color: var(--color-site-body);
  text-rendering: optimizelegibility;
  -webkit-tap-highlight-color: rgba(0,0,0,0);
  line-height: 1.6;
  -webkit-text-size-adjust: 100%;
  -ms-text-size-adjust: 100%;
}
body.modal-active {
  overflow: hidden;
}
@media screen and (max-width: 680px) {
  body.modal-active {
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
  }
}
a {
  color: #2092ec;
  cursor: pointer;
  text-decoration: none;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
a:hover {
  color: #ff5722;
}
a:active,
a:hover {
  outline: 0;
}
ul,
ol {
  padding-left: 0;
}
ul li,
ol li {
  list-style: none;
}
header {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
}
img {
  border: 0;
  background: none;
  max-width: 100%;
}
svg:not(:root) {
  overflow: hidden;
}
hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  -webkit-box-sizing: content-box;
  -moz-box-sizing: content-box;
  height: 0;
  border: 0;
  border-radius: 1px;
  -webkit-border-radius: 1px;
  border-bottom: 1px solid rgba(68,68,68,0.1);
}
button,
input {
  color: inherit;
  font: inherit;
  margin: 0;
}
button {
  overflow: visible;
  text-transform: none;
  -webkit-appearance: button;
  cursor: pointer;
}
@supports (backdrop-filter: blur(20px)) {
  .blur {
    background: rgba(255,255,255,0.9) !important;
    backdrop-filter: saturate(200%) blur(20px);
  }
}
.shadow {
  box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
  -webkit-box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
}
.shadow.floatable {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.shadow.floatable:hover {
  box-shadow: 0 2px 4px 0px rgba(0,0,0,0.1), 0 4px 8px 0px rgba(0,0,0,0.1), 0 8px 16px 0px rgba(0,0,0,0.1);
  -webkit-box-shadow: 0 2px 4px 0px rgba(0,0,0,0.1), 0 4px 8px 0px rgba(0,0,0,0.1), 0 8px 16px 0px rgba(0,0,0,0.1);
}
#l_cover {
  min-height: 64px;
}
.cover-wrapper {
  top: 0;
  left: 0;
  max-width: 100%;
  height: 100vh;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  flex-wrap: nowrap;
  -webkit-flex-wrap: nowrap;
  -khtml-flex-wrap: nowrap;
  -moz-flex-wrap: nowrap;
  -o-flex-wrap: nowrap;
  -ms-flex-wrap: nowrap;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: vertical;
  -moz-box-orient: vertical;
  -webkit-flex-direction: column;
  -ms-flex-direction: column;
  flex-direction: column;
  align-items: center;
  align-self: center;
  align-content: center;
  color: var(--color-site-inner);
  padding: 0 16px;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  position: relative;
  overflow: hidden;
  margin-bottom: -100px;
}
.cover-wrapper .cover-bg {
  position: absolute;
  width: 100%;
  height: 100%;
  background-position: center;
  background-size: cover;
  -webkit-background-size: cover;
  -moz-background-size: cover;
}
.cover-wrapper .cover-bg.lazyload:not(.loaded) {
  opacity: 0;
  -webkit-opacity: 0;
  -moz-opacity: 0;
}
.cover-wrapper .cover-bg.lazyload.loaded {
  animation-delay: 0s;
  animation-duration: 0.5s;
  animation-fill-mode: forwards;
  animation-timing-function: ease-out;
  animation-name: fadeIn;
}
@-moz-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
    transform: scale(1.02);
    -webkit-transform: scale(1.02);
    -khtml-transform: scale(1.02);
    -moz-transform: scale(1.02);
    -o-transform: scale(1.02);
    -ms-transform: scale(1.02);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-webkit-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
    transform: scale(1.02);
    -webkit-transform: scale(1.02);
    -khtml-transform: scale(1.02);
    -moz-transform: scale(1.02);
    -o-transform: scale(1.02);
    -ms-transform: scale(1.02);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-o-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
    transform: scale(1.02);
    -webkit-transform: scale(1.02);
    -khtml-transform: scale(1.02);
    -moz-transform: scale(1.02);
    -o-transform: scale(1.02);
    -ms-transform: scale(1.02);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
    transform: scale(1.02);
    -webkit-transform: scale(1.02);
    -khtml-transform: scale(1.02);
    -moz-transform: scale(1.02);
    -o-transform: scale(1.02);
    -ms-transform: scale(1.02);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
.cover-wrapper .cover-body {
  z-index: 1;
  position: relative;
  width: 100%;
  height: 100%;
}
.cover-wrapper#full {
  height: calc(100vh + 100px);
  padding-bottom: 100px;
}
.cover-wrapper#half {
  max-height: 640px;
  min-height: 400px;
  height: calc(36vh - 64px + 200px);
}
.cover-wrapper #scroll-down {
  width: 100%;
  height: 64px;
  position: absolute;
  bottom: 100px;
  text-align: center;
  cursor: pointer;
}
.cover-wrapper #scroll-down .scroll-down-effects {
  color: #fff;
  font-size: 24px;
  line-height: 64px;
  position: absolute;
  width: 24px;
  left: calc(50% - 12px);
  text-shadow: 0 1px 2px rgba(0,0,0,0.1);
  animation: scroll-down-effect 1.5s infinite;
  -webkit-animation: scroll-down-effect 1.5s infinite;
  -khtml-animation: scroll-down-effect 1.5s infinite;
  -moz-animation: scroll-down-effect 1.5s infinite;
  -o-animation: scroll-down-effect 1.5s infinite;
  -ms-animation: scroll-down-effect 1.5s infinite;
}
@-moz-keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-webkit-keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-o-keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
.cover-wrapper .cover-body {
  margin-top: 64px;
  margin-bottom: 100px;
}
.cover-wrapper .cover-body,
.cover-wrapper .cover-body .top,
.cover-wrapper .cover-body .bottom {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: vertical;
  -moz-box-orient: vertical;
  -webkit-flex-direction: column;
  -ms-flex-direction: column;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  -webkit-justify-content: center;
  -khtml-justify-content: center;
  -moz-justify-content: center;
  -o-justify-content: center;
  -ms-justify-content: center;
  max-width: 100%;
}
.cover-wrapper .cover-body .bottom {
  margin-top: 32px;
}
.cover-wrapper .cover-body .title {
  font-family: "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Helvetica, monospace;
  font-size: 3.125rem;
  line-height: 1.2;
  text-shadow: 0 1px 2px rgba(0,0,0,0.1);
}
.cover-wrapper .cover-body .subtitle {
  font-size: 20px;
}
.cover-wrapper .cover-body .logo {
  max-height: 120px;
  max-width: calc(100% - 4 * 16px);
}
@media screen and (min-height: 1024px) {
  .cover-wrapper .cover-body .title {
    font-size: 3rem;
  }
  .cover-wrapper .cover-body .subtitle {
    font-size: 1.05rem;
  }
  .cover-wrapper .cover-body .logo {
    max-height: 150px;
  }
}
.cover-wrapper .cover-body .m_search {
  position: relative;
  max-width: calc(100% - 16px);
  width: 320px;
  vertical-align: middle;
}
.cover-wrapper .cover-body .m_search .form {
  position: relative;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  width: 100%;
}
.cover-wrapper .cover-body .m_search .icon,
.cover-wrapper .cover-body .m_search .input {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.cover-wrapper .cover-body .m_search .icon {
  position: absolute;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  line-height: 2.5rem;
  width: 32px;
  top: 0;
  left: 5px;
  color: rgba(68,68,68,0.75);
}
.cover-wrapper .cover-body .m_search .input {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  height: 2.5rem;
  width: 100%;
  box-shadow: none;
  -webkit-box-shadow: none;
  box-sizing: border-box;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  font-size: 0.875rem;
  -webkit-appearance: none;
  padding-left: 36px;
  border-radius: 1.4rem;
  -webkit-border-radius: 1.4rem;
  background: rgba(255,255,255,0.6);
  backdrop-filter: blur(10px);
  border: none;
  color: var(--color-text);
}
@media screen and (max-width: 500px) {
  .cover-wrapper .cover-body .m_search .input {
    padding-left: 36px;
  }
}
.cover-wrapper .cover-body .m_search .input:hover {
  background: rgba(255,255,255,0.8);
}
.cover-wrapper .cover-body .m_search .input:focus {
  background: #fff;
}
.cover-wrapper .list-h {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: horizontal;
  -moz-box-orient: horizontal;
  -webkit-flex-direction: row;
  -ms-flex-direction: row;
  flex-direction: row;
  flex-wrap: wrap;
  -webkit-flex-wrap: wrap;
  -khtml-flex-wrap: wrap;
  -moz-flex-wrap: wrap;
  -o-flex-wrap: wrap;
  -ms-flex-wrap: wrap;
  align-items: stretch;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
}
.cover-wrapper .list-h a {
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  -webkit-flex: 1 0;
  -ms-flex: 1 0;
  flex: 1 0;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  font-weight: 600;
}
.cover-wrapper .list-h a img {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  border-radius: 2px;
  -webkit-border-radius: 2px;
  margin: 4px;
  min-width: 40px;
  max-width: 44px;
}
@media screen and (max-width: 768px) {
  .cover-wrapper .list-h a img {
    min-width: 36px;
    max-width: 40px;
  }
}
@media screen and (max-width: 500px) {
  .cover-wrapper .list-h a img {
    margin: 2px 4px;
    min-width: 32px;
    max-width: 36px;
  }
}
@media screen and (max-width: 375px) {
  .cover-wrapper .list-h a img {
    min-width: 28px;
    max-width: 32px;
  }
}
.cover-wrapper {
  max-width: 100%;
}
.cover-wrapper.search .bottom .menu {
  margin-top: 16px;
}
.cover-wrapper.search .bottom .menu .list-h a {
  white-space: nowrap;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: horizontal;
  -moz-box-orient: horizontal;
  -webkit-flex-direction: row;
  -ms-flex-direction: row;
  flex-direction: row;
  align-items: baseline;
  padding: 2px;
  margin: 4px;
  color: var(--color-site-inner);
  opacity: 0.75;
  -webkit-opacity: 0.75;
  -moz-opacity: 0.75;
  text-shadow: 0 1px 2px rgba(0,0,0,0.05);
  border-bottom: 2px solid transparent;
}
.cover-wrapper.search .bottom .menu .list-h a i {
  margin-right: 4px;
}
.cover-wrapper.search .bottom .menu .list-h a p {
  font-size: 0.9375rem;
}
.cover-wrapper.search .bottom .menu .list-h a:hover,
.cover-wrapper.search .bottom .menu .list-h a.active,
.cover-wrapper.search .bottom .menu .list-h a:active {
  opacity: 1;
  -webkit-opacity: 1;
  -moz-opacity: 1;
  border-bottom: 2px solid var(--color-site-inner);
}
.cover-wrapper.dock .menu,
.cover-wrapper.featured .menu,
.cover-wrapper.focus .menu {
  border-radius: 6px;
  -webkit-border-radius: 6px;
}
.cover-wrapper.dock .menu .list-h a,
.cover-wrapper.featured .menu .list-h a,
.cover-wrapper.focus .menu .list-h a {
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: vertical;
  -moz-box-orient: vertical;
  -webkit-flex-direction: column;
  -ms-flex-direction: column;
  flex-direction: column;
  align-items: center;
  padding: 12px;
  line-height: 24px;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  border-bottom: none;
  text-align: center;
  align-content: flex-end;
  color: rgba(68,68,68,0.7);
  font-size: 1.5rem;
}
@media screen and (max-width: 500px) {
  .cover-wrapper.dock .menu .list-h a,
  .cover-wrapper.featured .menu .list-h a,
  .cover-wrapper.focus .menu .list-h a {
    padding: 12px 8px;
  }
}
.cover-wrapper.dock .menu .list-h a i,
.cover-wrapper.featured .menu .list-h a i,
.cover-wrapper.focus .menu .list-h a i {
  margin: 8px;
}
.cover-wrapper.dock .menu .list-h a p,
.cover-wrapper.featured .menu .list-h a p,
.cover-wrapper.focus .menu .list-h a p {
  font-size: 0.875rem;
}
.cover-wrapper.dock .menu .list-h a.active,
.cover-wrapper.featured .menu .list-h a.active,
.cover-wrapper.focus .menu .list-h a.active {
  background: var(--color-card);
  backdrop-filter: none;
}
.cover-wrapper.dock .menu .list-h a.active i,
.cover-wrapper.featured .menu .list-h a.active i,
.cover-wrapper.focus .menu .list-h a.active i,
.cover-wrapper.dock .menu .list-h a.active i+p,
.cover-wrapper.featured .menu .list-h a.active i+p,
.cover-wrapper.focus .menu .list-h a.active i+p {
  color: #3dd9b6;
}
.cover-wrapper.dock .menu .list-h a.active img+p,
.cover-wrapper.featured .menu .list-h a.active img+p,
.cover-wrapper.focus .menu .list-h a.active img+p {
  color: var(--color-text);
}
.cover-wrapper.dock .menu .list-h a:hover,
.cover-wrapper.featured .menu .list-h a:hover,
.cover-wrapper.focus .menu .list-h a:hover {
  background: var(--color-card);
}
.cover-wrapper.dock .top {
  margin-bottom: 48px;
}
.cover-wrapper.dock .menu {
  background: rgba(255,255,255,0.5);
  position: absolute;
  bottom: 0;
  max-width: 100%;
}
.cover-wrapper.dock .menu .list-h {
  flex-wrap: nowrap;
  -webkit-flex-wrap: nowrap;
  -khtml-flex-wrap: nowrap;
  -moz-flex-wrap: nowrap;
  -o-flex-wrap: nowrap;
  -ms-flex-wrap: nowrap;
  margin: 4px;
}
.cover-wrapper.dock .menu .list-h a+a {
  margin-left: 4px;
}
@media screen and (max-width: 500px) {
  .cover-wrapper.dock .menu .list-h {
    overflow-x: scroll;
  }
  .cover-wrapper.dock .menu .list-h::-webkit-scrollbar {
    height: 0;
    width: 0;
  }
  .cover-wrapper.dock .menu .list-h::-webkit-scrollbar-track-piece {
    background: transparent;
  }
  .cover-wrapper.dock .menu .list-h::-webkit-scrollbar-thumb {
    background: #3dd9b6;
    cursor: pointer;
    border-radius: 0;
    -webkit-border-radius: 0;
  }
  .cover-wrapper.dock .menu .list-h::-webkit-scrollbar-thumb:hover {
    background: #ff5722;
  }
}
@supports (backdrop-filter: blur(20px)) {
  .cover-wrapper.dock .menu {
    background: rgba(255,255,255,0.5);
    backdrop-filter: saturate(200%) blur(20px);
  }
}
@font-face {
  font-family: 'UbuntuMono';
  src: url("https://unpkg.com/volantis-static@0.0.1654736714924/media/fonts/UbuntuMono/UbuntuMono-Regular.ttf");
  font-weight: 'normal';
  font-style: 'normal';
  font-display: swap;
}
@font-face {
  font-family: 'Varela Round';
  src: url("https://unpkg.com/volantis-static@0.0.1654736714924/media/fonts/VarelaRound/VarelaRound-Regular.ttf");
  font-weight: 'normal';
  font-style: 'normal';
  font-display: swap;
}
.l_header {
  position: fixed;
  z-index: 1000;
  top: 0;
  width: 100%;
  height: 64px;
  background: var(--color-card);
  box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
  -webkit-box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
}
.l_header.auto {
  transition: opacity 0.4s ease;
  -webkit-transition: opacity 0.4s ease;
  -khtml-transition: opacity 0.4s ease;
  -moz-transition: opacity 0.4s ease;
  -o-transition: opacity 0.4s ease;
  -ms-transition: opacity 0.4s ease;
  visibility: hidden;
}
.l_header.auto.show {
  opacity: 1 !important;
  -webkit-opacity: 1 !important;
  -moz-opacity: 1 !important;
  visibility: visible;
}
.l_header .container {
  margin-left: 16px;
  margin-right: 16px;
}
.l_header #wrapper {
  height: 100%;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
}
.l_header #wrapper .nav-main,
.l_header #wrapper .nav-sub {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  flex-wrap: nowrap;
  -webkit-flex-wrap: nowrap;
  -khtml-flex-wrap: nowrap;
  -moz-flex-wrap: nowrap;
  -o-flex-wrap: nowrap;
  -ms-flex-wrap: nowrap;
  justify-content: space-between;
  -webkit-justify-content: space-between;
  -khtml-justify-content: space-between;
  -moz-justify-content: space-between;
  -o-justify-content: space-between;
  -ms-justify-content: space-between;
  align-items: center;
}
.l_header #wrapper .nav-main {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.l_header #wrapper.sub .nav-main {
  transform: translateY(-64px);
  -webkit-transform: translateY(-64px);
  -khtml-transform: translateY(-64px);
  -moz-transform: translateY(-64px);
  -o-transform: translateY(-64px);
  -ms-transform: translateY(-64px);
}
.l_header #wrapper .nav-sub {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  opacity: 0;
  -webkit-opacity: 0;
  -moz-opacity: 0;
  height: 64px;
  width: calc(100% - 2 * 16px);
  position: absolute;
}
.l_header #wrapper .nav-sub ::-webkit-scrollbar {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
}
@media screen and (min-width: 2048px) {
  .l_header #wrapper .nav-sub {
    max-width: 55vw;
    margin: auto;
  }
}
.l_header #wrapper.sub .nav-sub {
  opacity: 1;
  -webkit-opacity: 1;
  -moz-opacity: 1;
}
.l_header #wrapper .title {
  position: relative;
  color: var(--color-text);
  padding-left: 24px;
  max-height: 64px;
}
.l_header #wrapper .nav-main .title {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  flex-shrink: 0;
  line-height: 64px;
  padding: 0 24px;
  font-size: 1.25rem;
  font-family: "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Helvetica, monospace;
}
.l_header #wrapper .nav-main .title img {
  height: 64px;
}
.l_header .nav-sub {
  max-width: 1080px;
  margin: auto;
}
.l_header .nav-sub .title {
  font-weight: bold;
  font-family: UbuntuMono, "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Menlo, Monaco, monospace, sans-serif;
  line-height: 1.2;
  max-height: 64px;
  white-space: normal;
  flex-shrink: 1;
}
.l_header .switcher {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  line-height: 64px;
  align-items: center;
}
.l_header .switcher .s-toc {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
}
@media screen and (max-width: 768px) {
  .l_header .switcher .s-toc {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: -ms-flexbox /* TWEENER - IE 10 */;
    display: -webkit-flex /* NEW - Chrome */;
    display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
    display: flex;
  }
}
.l_header .switcher >li {
  height: 48px;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  margin: 2px;
}
@media screen and (max-width: 500px) {
  .l_header .switcher >li {
    margin: 0 1px;
    height: 48px;
  }
}
.l_header .switcher >li >a {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  justify-content: center;
  -webkit-justify-content: center;
  -khtml-justify-content: center;
  -moz-justify-content: center;
  -o-justify-content: center;
  -ms-justify-content: center;
  align-items: center;
  width: 48px;
  height: 48px;
  padding: 0.85em 1.1em;
  border-radius: 100px;
  -webkit-border-radius: 100px;
  border: none;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  color: #3dd9b6;
}
.l_header .switcher >li >a:hover {
  border: none;
}
.l_header .switcher >li >a.active,
.l_header .switcher >li >a:active {
  border: none;
  background: var(--color-site-bg);
}
@media screen and (max-width: 500px) {
  .l_header .switcher >li >a {
    width: 36px;
    height: 48px;
  }
}
.l_header .nav-sub .switcher {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
}
.l_header .m_search {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  height: 64px;
  width: 240px;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
@media screen and (max-width: 1024px) {
  .l_header .m_search {
    width: 44px;
    min-width: 44px;
  }
  .l_header .m_search input::placeholder {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
  }
  .l_header .m_search:hover {
    width: 240px;
  }
  .l_header .m_search:hover input::placeholder {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@media screen and (min-width: 500px) {
  .l_header .m_search:hover .input {
    width: 100%;
  }
  .l_header .m_search:hover .input::placeholder {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@media screen and (max-width: 500px) {
  .l_header .m_search {
    min-width: 0;
  }
  .l_header .m_search input::placeholder {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
.l_header .m_search .form {
  position: relative;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  width: 100%;
  align-items: center;
}
.l_header .m_search .icon {
  position: absolute;
  width: 36px;
  left: 5px;
  color: var(--color-meta);
}
@media screen and (max-width: 500px) {
  .l_header .m_search .icon {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: none;
  }
}
.l_header .m_search .input {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  padding-top: 8px;
  padding-bottom: 8px;
  line-height: 1.3;
  width: 100%;
  color: var(--color-text);
  background: #fafafa;
  box-shadow: none;
  -webkit-box-shadow: none;
  box-sizing: border-box;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  padding-left: 40px;
  font-size: 0.875rem;
  border-radius: 8px;
  -webkit-border-radius: 8px;
  border: none;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
@media screen and (min-width: 500px) {
  .l_header .m_search .input:focus {
    box-shadow: 0 4px 8px 0px rgba(0,0,0,0.1);
    -webkit-box-shadow: 0 4px 8px 0px rgba(0,0,0,0.1);
  }
}
@media screen and (max-width: 500px) {
  .l_header .m_search .input {
    background: var(--color-block);
    padding-left: 8px;
    border: none;
  }
  .l_header .m_search .input:hover,
  .l_header .m_search .input:focus {
    border: none;
  }
}
@media (max-width: 500px) {
  .l_header .m_search {
    left: 0;
    width: 0;
    overflow: hidden;
    position: absolute;
    background: #fff;
    transition: all 0.28s ease;
    -webkit-transition: all 0.28s ease;
    -khtml-transition: all 0.28s ease;
    -moz-transition: all 0.28s ease;
    -o-transition: all 0.28s ease;
    -ms-transition: all 0.28s ease;
  }
  .l_header .m_search .input {
    border-radius: 32px;
    -webkit-border-radius: 32px;
    margin-left: 16px;
    padding-left: 16px;
  }
  .l_header.z_search-open .m_search {
    width: 100%;
  }
  .l_header.z_search-open .m_search .input {
    width: calc(100% - 120px);
  }
}
ul.m-pc >li>a {
  color: inherit;
  border-bottom: 2px solid transparent;
}
ul.m-pc >li>a:active,
ul.m-pc >li>a.active {
  border-bottom: 2px solid #3dd9b6;
}
ul.m-pc li:hover >ul.list-v,
ul.list-v li:hover >ul.list-v {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
}
ul.nav-list-h {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  align-items: stretch;
}
ul.nav-list-h>li {
  position: relative;
  justify-content: center;
  -webkit-justify-content: center;
  -khtml-justify-content: center;
  -moz-justify-content: center;
  -o-justify-content: center;
  -ms-justify-content: center;
  height: 100%;
  line-height: 2.4;
  border-radius: 4px;
  -webkit-border-radius: 4px;
}
ul.nav-list-h>li >a {
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  font-weight: 600;
}
ul.list-v {
  z-index: 1;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  position: absolute;
  background: var(--color-card);
  box-shadow: 0 2px 4px 0px rgba(0,0,0,0.08), 0 4px 8px 0px rgba(0,0,0,0.08), 0 8px 16px 0px rgba(0,0,0,0.08);
  -webkit-box-shadow: 0 2px 4px 0px rgba(0,0,0,0.08), 0 4px 8px 0px rgba(0,0,0,0.08), 0 8px 16px 0px rgba(0,0,0,0.08);
  margin-top: -6px;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  padding: 8px 0;
}
ul.list-v.show {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
}
ul.list-v hr {
  margin-top: 8px;
  margin-bottom: 8px;
}
ul.list-v >li {
  white-space: nowrap;
  word-break: keep-all;
}
ul.list-v >li.header {
  font-size: 0.78125rem;
  font-weight: bold;
  line-height: 2em;
  color: var(--color-meta);
  margin: 8px 16px 4px;
}
ul.list-v >li.header i {
  margin-right: 8px;
}
ul.list-v >li ul {
  margin-left: 0;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  margin-top: -40px;
}
ul.list-v .aplayer-container {
  min-height: 64px;
  padding: 6px 16px;
}
ul.list-v >li>a {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  color: var(--color-list);
  font-size: 0.875rem;
  font-weight: bold;
  line-height: 36px;
  padding: 0 20px 0 16px;
  text-overflow: ellipsis;
  margin: 0 4px;
  border-radius: 4px;
  -webkit-border-radius: 4px;
}
@media screen and (max-width: 1024px) {
  ul.list-v >li>a {
    line-height: 40px;
  }
}
ul.list-v >li>a >i {
  margin-right: 8px;
}
ul.list-v >li>a:active,
ul.list-v >li>a.active {
  color: var(--color-list-hl);
}
ul.list-v >li>a:hover {
  color: var(--color-list-hl);
  background: var(--color-site-bg);
}
.l_header .menu >ul>li>a {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  padding: 0 8px;
}
.l_header .menu >ul>li>a >i {
  margin-right: 4px;
}
.l_header ul.nav-list-h>li {
  color: var(--color-list);
  line-height: 64px;
}
.l_header ul.nav-list-h>li >a {
  max-height: 64px;
  overflow: hidden;
  color: inherit;
}
.l_header ul.nav-list-h>li >a:active,
.l_header ul.nav-list-h>li >a.active {
  color: #3dd9b6;
}
.l_header ul.nav-list-h>li:hover>a {
  color: var(--color-list-hl);
}
.l_header ul.nav-list-h>li i.music {
  animation: rotate-effect 1.5s linear infinite;
  -webkit-animation: rotate-effect 1.5s linear infinite;
  -khtml-animation: rotate-effect 1.5s linear infinite;
  -moz-animation: rotate-effect 1.5s linear infinite;
  -o-animation: rotate-effect 1.5s linear infinite;
  -ms-animation: rotate-effect 1.5s linear infinite;
}
@-moz-keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
@-webkit-keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
@-o-keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
@keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
.menu-phone li ul.list-v {
  right: calc(100% - 0.5 * 16px);
}
.menu-phone li ul.list-v ul {
  right: calc(100% - 0.5 * 16px);
}
#wrapper {
  max-width: 1080px;
  margin: auto;
}
@media screen and (min-width: 2048px) {
  #wrapper {
    max-width: 55vw;
  }
}
#wrapper .menu {
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  -webkit-flex: 1 1;
  -ms-flex: 1 1;
  flex: 1 1;
  margin: 0 16px 0 0;
}
#wrapper .menu .list-v ul {
  left: calc(100% - 0.5 * 16px);
}
.menu-phone {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  margin-top: 16px;
  right: 8px;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.menu-phone ul {
  right: calc(100% - 0.5 * 16px);
}
@media screen and (max-width: 500px) {
  .menu-phone {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: block;
  }
}
.l_header {
  max-width: 65vw;
  left: calc((100% - 65vw) * 0.5);
  border-bottom-left-radius: 8px;
  border-bottom-right-radius: 8px;
}
@media screen and (max-width: 2048px) {
  .l_header {
    max-width: 1112px;
    left: calc((100% - 1112px) * 0.5);
  }
}
@media screen and (max-width: 1112px) {
  .l_header {
    left: 0;
    border-radius: 0;
    -webkit-border-radius: 0;
    max-width: 100%;
  }
}
@media screen and (max-width: 500px) {
  .l_header .container {
    margin-left: 0;
    margin-right: 0;
  }
  .l_header #wrapper .nav-main .title {
    padding-left: 16px;
    padding-right: 16px;
  }
  .l_header #wrapper .nav-sub {
    width: 100%;
  }
  .l_header #wrapper .nav-sub .title {
    overflow-y: scroll;
    margin-top: 2px;
    padding: 8px 16px;
  }
  .l_header #wrapper .switcher {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: -ms-flexbox /* TWEENER - IE 10 */;
    display: -webkit-flex /* NEW - Chrome */;
    display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
    display: flex;
    margin-right: 8px;
  }
  .l_header .menu {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: none;
  }
}
@media screen and (max-width: 500px) {
  .list-v li {
    max-width: 270px;
  }
}
#u-search {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  padding: 60px 20px;
  z-index: 1001;
}
@media screen and (max-width: 680px) {
  #u-search {
    padding: 0px;
  }
}

  </style>
  <link rel="stylesheet" href="/css/style.css" media="print" onload="this.media='all';this.onload=null">
  <noscript><link rel="stylesheet" href="/css/style.css"></noscript>
  
<script>
if (/*@cc_on!@*/false || (!!window.MSInputMethodContext && !!document.documentMode))
    document.write(
	'<style>'+
		'html{'+
			'overflow-x: hidden !important;'+
			'overflow-y: hidden !important;'+
		'}'+
		'.kill-ie{'+
			'text-align:center;'+
			'height: 100%;'+
			'margin-top: 15%;'+
			'margin-bottom: 5500%;'+
		'}'+
    '.kill-t{'+
      'font-size: 2rem;'+
    '}'+
    '.kill-c{'+
      'font-size: 1.2rem;'+
    '}'+
		'#l_header,#l_body{'+
			'display: none;'+
		'}'+
	'</style>'+
    '<div class="kill-ie">'+
        `<span class="kill-t"><b>抱歉，您的浏览器无法访问本站</b></span><br/>`+
        `<span class="kill-c">微软已经于2016年终止了对 Internet Explorer (IE) 10 及更早版本的支持，<br/>继续使用存在极大的安全隐患，请使用当代主流的浏览器进行访问。</span><br/>`+
        `<a target="_blank" rel="noopener" href="https://blogs.windows.com/windowsexperience/2021/05/19/the-future-of-internet-explorer-on-windows-10-is-in-microsoft-edge/"><strong>了解详情 ></strong></a>`+
    '</div>');
</script>


<noscript>
	<style>
		html{
			overflow-x: hidden !important;
			overflow-y: hidden !important;
		}
		.kill-noscript{
			text-align:center;
			height: 100%;
			margin-top: 15%;
			margin-bottom: 5500%;
		}
    .kill-t{
      font-size: 2rem;
    }
    .kill-c{
      font-size: 1.2rem;
    }
		#l_header,#l_body{
			display: none;
		}
	</style>
    <div class="kill-noscript">
        <span class="kill-t"><b>抱歉，您的浏览器无法访问本站</b></span><br/>
        <span class="kill-c">本页面需要浏览器支持（启用）JavaScript</span><br/>
        <a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=启用JavaScript"><strong>了解详情 ></strong></a>
    </div>
</noscript>


  <script>
  /************这个文件存放不需要重载的全局变量和全局函数*********/
  window.volantis = {}; // volantis 全局变量
  volantis.debug = "env"; // 调试模式
  volantis.dom = {}; // 页面Dom see: /source/js/app.js etc.

  volantis.GLOBAL_CONFIG ={
    debug: "env",
    cdn: {"js":{"app":"/js/app.js","parallax":"/js/plugins/parallax.js","rightMenu":"/js/plugins/rightMenu.js","rightMenus":"/js/plugins/rightMenus.js","sites":"/js/plugins/tags/sites.js","friends":"/js/plugins/tags/friends.js","contributors":"/js/plugins/tags/contributors.js","search":"/js/search/hexo.js"},"css":{"style":"/css/style.css"}},
    default: {"avatar":"https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/avatar/round/3442075.svg","link":"https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/link/8f277b4ee0ecd.svg","cover":"https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/cover/76b86c0226ffd.svg","image":"https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/image/2659360.svg"},
    lastupdate: new Date(1756982446435),
    sidebar: {
      for_page: ["blogger","category","tagcloud","donate"],
      for_post: ["toc"],
      webinfo: {
        lastupd: {
          enable: true,
          friendlyShow: true
        },
        runtime: {
          data: "2020/01/01",
          unit: "天"
        }
      }
    },
    plugins: {
      message: {"enable":true,"css":"https://unpkg.com/volantis-static@0.0.1654736714924/libs/izitoast/dist/css/iziToast.min.css","js":"https://unpkg.com/volantis-static@0.0.1654736714924/libs/izitoast/dist/js/iziToast.min.js","icon":{"default":"fa-solid fa-info-circle light-blue","quection":"fa-solid fa-question-circle light-blue"},"time":{"default":5000,"quection":20000},"position":"topRight","transitionIn":"bounceInLeft","transitionOut":"fadeOutRight","titleColor":"var(--color-text)","messageColor":"var(--color-text)","backgroundColor":"var(--color-card)","zindex":2147483647,"copyright":{"enable":true,"title":"知识共享许可协议","message":"请遵守 CC BY-NC-SA 4.0 协议。","icon":"far fa-copyright light-blue"},"aplayer":{"enable":true,"play":"fa-solid fa-play","pause":"fa-solid fa-pause"},"rightmenu":{"enable":true,"notice":true}},
      fancybox: {"css":"https://unpkg.com/volantis-static@0.0.1654736714924/libs/@fancyapps/ui/dist/fancybox.css","js":"https://unpkg.com/volantis-static@0.0.1654736714924/libs/@fancyapps/ui/dist/fancybox.umd.js"},
      
      
      
    }
  }

  /******************** volantis.EventListener ********************************/
  // 事件监听器 see: /source/js/app.js
  volantis.EventListener = {}
  // 这里存放pjax切换页面时将被移除的事件监听器
  volantis.EventListener.list = []
  //构造方法
  function volantisEventListener(type, f, ele) {
    this.type = type
    this.f = f
    this.ele = ele
  }
  // 移除事件监听器
  volantis.EventListener.remove = () => {
    volantis.EventListener.list.forEach(function (i) {
      i.ele.removeEventListener(i.type, i.f, false)
    })
    volantis.EventListener.list = []
  }
  /******************** volantis.dom.$ ********************************/
  // 注：这里没有选择器，也没有forEach一次只处理一个dom，这里重新封装主题常用的dom方法，返回的是dom对象，对象包含了以下方法，同时保留dom的原生API
  function volantisDom(ele) {
    if (!ele) ele = document.createElement("div")
    this.ele = ele;
    // ==============================================================
    this.ele.find = (c) => {
      let q = this.ele.querySelector(c)
      if (q)
        return new volantisDom(q)
    }
    // ==============================================================
    this.ele.hasClass = (c) => {
      return this.ele.className.match(new RegExp('(\\s|^)' + c + '(\\s|$)'));
    }
    this.ele.addClass = (c) => {
      this.ele.classList.add(c);
      return this.ele
    }
    this.ele.removeClass = (c) => {
      this.ele.classList.remove(c);
      return this.ele
    }
    this.ele.toggleClass = (c) => {
      if (this.ele.hasClass(c)) {
        this.ele.removeClass(c)
      } else {
        this.ele.addClass(c)
      }
      return this.ele
    }
    // ==============================================================
    // 参数 r 为 true 表示pjax切换页面时事件监听器将被移除，false不移除
    this.ele.on = (c, f, r = 1) => {
      this.ele.addEventListener(c, f, false)
      if (r) {
        volantis.EventListener.list.push(new volantisEventListener(c, f, this.ele))
      }
      return this.ele
    }
    this.ele.click = (f, r) => {
      this.ele.on("click", f, r)
      return this.ele
    }
    this.ele.scroll = (f, r) => {
      this.ele.on("scroll", f, r)
      return this.ele
    }
    // ==============================================================
    this.ele.html = (c) => {
      // if(c=== undefined){
      //   return this.ele.innerHTML
      // }else{
      this.ele.innerHTML = c
      return this.ele
      // }
    }
    // ==============================================================
    this.ele.hide = (c) => {
      this.ele.style.display = "none"
      return this.ele
    }
    this.ele.show = (c) => {
      this.ele.style.display = "block"
      return this.ele
    }
    // ==============================================================
    return this.ele
  }
  volantis.dom.$ = (ele) => {
    return !!ele ? new volantisDom(ele) : null;
  }
  /******************** RunItem ********************************/
  function RunItem() {
    this.list = []; // 存放回调函数
    this.start = () => {
      for (var i = 0; i < this.list.length; i++) {
        this.list[i].run();
      }
    };
    this.push = (fn, name, setRequestAnimationFrame = true) => {
      let myfn = fn
      if (setRequestAnimationFrame) {
        myfn = ()=>{
          volantis.requestAnimationFrame(fn)
        }
      }
      var f = new Item(myfn, name);
      this.list.push(f);
    };
    this.remove = (name) =>{
      for (let index = 0; index < this.list.length; index++) {
        const e = this.list[index];
        if (e.name == name) {
          this.list.splice(index,1);
        }
      }
    }
    // 构造一个可以run的对象
    function Item(fn, name) {
      // 函数名称
      this.name = name || fn.name;
      // run方法
      this.run = () => {
        try {
          fn()
        } catch (error) {
          console.log(error);
        }
      };
    }
  }
  /******************** Pjax ********************************/
  // /layout/_plugins/pjax/index.ejs
  // volantis.pjax.send(callBack[,"callBackName"]) 传入pjax:send回调函数
  // volantis.pjax.push(callBack[,"callBackName"]) 传入pjax:complete回调函数
  // volantis.pjax.error(callBack[,"callBackName"]) 传入pjax:error回调函数
  volantis.pjax = {};
  volantis.pjax.method = {
    complete: new RunItem(),
    error: new RunItem(),
    send: new RunItem(),
  };
  volantis.pjax = Object.assign(volantis.pjax, {
    push: volantis.pjax.method.complete.push,
    error: volantis.pjax.method.error.push,
    send: volantis.pjax.method.send.push,
  });
  /******************** RightMenu ********************************/
  // volantis.rightmenu.handle(callBack[,"callBackName"]) 外部菜单项控制
  // 可在 volantis.mouseEvent 处获取右键事件
  volantis.rightmenu = {};
  volantis.rightmenu.method = {
    handle: new RunItem(),
  }
  volantis.rightmenu = Object.assign(volantis.rightmenu, {
    handle: volantis.rightmenu.method.handle.push,
  });
  /********************  Dark Mode  ********************************/
  // /layout/_partial/scripts/darkmode.ejs
  // volantis.dark.mode 当前模式 dark or light
  // volantis.dark.toggle() 暗黑模式触发器
  // volantis.dark.push(callBack[,"callBackName"]) 传入触发器回调函数
  volantis.dark = {};
  volantis.dark.method = {
    toggle: new RunItem(),
  };
  volantis.dark = Object.assign(volantis.dark, {
    push: volantis.dark.method.toggle.push,
  });
  /********************  Message  ********************************/
  // VolantisApp.message
  /********************  isMobile  ********************************/
  // /source/js/app.js
  // volantis.isMobile
  // volantis.isMobileOld
  /********************脚本动态加载函数********************************/
  // volantis.js(src, cb)  cb 可以传入onload回调函数 或者 JSON对象 例如: volantis.js("src", ()=>{}) 或 volantis.js("src", {defer:true,onload:()=>{}})
  // volantis.css(src)

  // 返回Promise对象，如下方法同步加载资源，这利于处理文件资源之间的依赖关系，例如：APlayer 需要在 MetingJS 之前加载
  // (async () => {
  //     await volantis.js("...theme.plugins.aplayer.js.aplayer...")
  //     await volantis.js("...theme.plugins.aplayer.js.meting...")
  // })();

  // 已经加入了setTimeout
  volantis.js = (src, cb) => {
    return new Promise(resolve => {
      setTimeout(function () {
        var HEAD = document.getElementsByTagName("head")[0] || document.documentElement;
        var script = document.createElement("script");
        script.setAttribute("type", "text/javascript");
        if (cb) {
          if (JSON.stringify(cb)) {
            for (let p in cb) {
              if (p == "onload") {
                script[p] = () => {
                  cb[p]()
                  resolve()
                }
              } else {
                script[p] = cb[p]
                script.onload = resolve
              }
            }
          } else {
            script.onload = () => {
              cb()
              resolve()
            };
          }
        } else {
          script.onload = resolve
        }
        script.setAttribute("src", src);
        HEAD.appendChild(script);
      });
    });
  }
  volantis.css = (src) => {
    return new Promise(resolve => {
      setTimeout(function () {
        var link = document.createElement('link');
        link.rel = "stylesheet";
        link.href = src;
        link.onload = resolve;
        document.getElementsByTagName("head")[0].appendChild(link);
      });
    });
  }
  /********************按需加载的插件********************************/
  // volantis.import.jQuery().then(()=>{})
  volantis.import = {
    jQuery: () => {
      if (typeof jQuery == "undefined") {
        return volantis.js("https://unpkg.com/volantis-static@0.0.1654736714924/libs/jquery/dist/jquery.min.js")
      } else {
        return new Promise(resolve => {
          resolve()
        });
      }
    }
  }
  /********************** requestAnimationFrame ********************************/
  // 1、requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。
  // 2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。
  volantis.requestAnimationFrame = (fn)=>{
    if (!window.requestAnimationFrame) {
      window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
    }
    window.requestAnimationFrame(fn)
  }
  /************************ layoutHelper *****************************************/
  volantis.layoutHelper = (helper, html, opt)=>{
    opt = Object.assign({clean:false, pjax:true}, opt)
    function myhelper(helper, html, clean) {
      volantis.tempDiv = document.createElement("div");
      volantis.tempDiv.innerHTML = html;
      let layoutHelper = document.querySelector("#layoutHelper-"+helper)
      if (layoutHelper) {
        if (clean) {
          layoutHelper.innerHTML = ""
        }
        layoutHelper.append(volantis.tempDiv);
      }
    }
    myhelper(helper, html, opt.clean)
    if (opt.pjax) {
      volantis.pjax.push(()=>{
        myhelper(helper, html, opt.clean)
      },"layoutHelper-"+helper)
    }
  }
  /****************************** 滚动事件处理 ****************************************/
  volantis.scroll = {
    engine: new RunItem(),
    unengine: new RunItem(),
  };
  volantis.scroll = Object.assign(volantis.scroll, {
    push: volantis.scroll.engine.push,
  });
  // 滚动条距离顶部的距离
  volantis.scroll.getScrollTop = () =>{
    let scrollPos;
    if (window.pageYOffset) {
      scrollPos = window.pageYOffset;
    } else if (document.compatMode && document.compatMode != 'BackCompat') {
      scrollPos = document.documentElement.scrollTop;
    } else if (document.body) {
      scrollPos = document.body.scrollTop;
    }
    return scrollPos;
  }
  // 使用 requestAnimationFrame 处理滚动事件
  // `volantis.scroll.del` 中存储了一个数值, 该数值检测一定时间间隔内滚动条滚动的位移, 数值的检测频率是浏览器的刷新频率. 数值为正数时, 表示向下滚动. 数值为负数时, 表示向上滚动.
  volantis.scroll.handleScrollEvents = () => {
    volantis.scroll.lastScrollTop = volantis.scroll.getScrollTop()
    function loop() {
      const scrollTop = volantis.scroll.getScrollTop();
      if (volantis.scroll.lastScrollTop !== scrollTop) {
        volantis.scroll.del = scrollTop - volantis.scroll.lastScrollTop;
        volantis.scroll.lastScrollTop = scrollTop;
        // if (volantis.scroll.del > 0) {
        //   console.log("向下滚动");
        // } else {
        //   console.log("向上滚动");
        // }
        // 注销过期的unengine未滚动事件
        volantis.scroll.unengine.list=[]
        volantis.scroll.engine.start();
      }else{
        volantis.scroll.unengine.start();
      }
      volantis.requestAnimationFrame(loop)
    }
    volantis.requestAnimationFrame(loop)
  }
  volantis.scroll.handleScrollEvents()
  volantis.scroll.ele = null;
  // 触发页面滚动至目标元素位置
  volantis.scroll.to = (ele, option = {}) => {
    if (!ele) return;
    volantis.scroll.ele = ele;
    // 默认配置
    opt = {
      top: ele.getBoundingClientRect().top + document.documentElement.scrollTop,
      behavior: "smooth"
    }
    // 定义配置
    if ("top" in option) {
      opt.top = option.top
    }
    if ("behavior" in option) {
      opt.behavior = option.behavior
    }
    if ("addTop" in option) {
      opt.top += option.addTop
    }
    if (!("observerDic" in option)) {
      option.observerDic = 100
    }
    // 滚动
    window.scrollTo(opt);
    // 监视器
    // 监视并矫正元素滚动到指定位置
    // 用于处理 lazyload 引起的 cls 导致的定位失败问题
    // option.observer = false
    if (option.observer) {
      setTimeout(() => {
        if (volantis.scroll.ele != ele) {
          return
        }
        volantis.scroll.unengine.push(() => {
          let me = ele.getBoundingClientRect().top
          if(!(me >= -option.observerDic && me <= option.observerDic)){
            volantis.scroll.to(ele, option)
          }
          volantis.scroll.unengine.remove("unengineObserver")
        },"unengineObserver")
      },1000)
    }
  }
  /********************** Content Visibility ********************************/
  // 见 source/css/first.styl 如果遇到任何问题 删除 .post-story 即可
  // 一个元素被声明 content-visibility 属性后 如果元素不在 viewport 中 浏览器不会计算其后代元素样式和属性 从而节省 Style & Layout 耗时
  // content-visibility 的副作用: 锚点失效 等等(实验初期 暂不明确), 使用此方法清除样式
  volantis.cleanContentVisibility = ()=>{
    if (document.querySelector(".post-story")) {
      console.log("cleanContentVisibility");
      document.querySelectorAll(".post-story").forEach(e=>{
        e.classList.remove("post-story")
      })
    }
  }
  /******************************************************************************/
  /******************************************************************************/
  /******************************************************************************/
  //图像加载出错时的处理
  function errorImgAvatar(img) {
    img.src = "https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/avatar/round/3442075.svg";
    img.onerror = null;
  }
  function errorImgCover(img) {
    img.src = "https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/cover/76b86c0226ffd.svg";
    img.onerror = null;
  }
  /******************************************************************************/
</script>

  <!-- import head_end begin -->
  <!-- import head_end end -->
  <!-- Custom Files headEnd begin-->
  
  <!-- Custom Files headEnd end-->
  <!-- front-matter head_end begin -->
  <!-- front-matter head_end end -->
</head>
  <body itemscope itemtype="http://schema.org/WebPage">
    <!-- import body_begin begin-->
    <!-- import body_begin end-->
    <!-- Custom Files bodyBegin begin-->
    
    <!-- Custom Files bodyBegin end-->
    <!-- front-matter body_begin begin -->
    <!-- front-matter body_begin end -->
    <header itemscope itemtype="http://schema.org/WPHeader" id="l_header" class="l_header auto shadow floatable blur show" style='opacity: 0' >
  <div class='container'>
  <div id='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h m-phone' id="pjax-header-nav-list">
        <li><a id="s-comment" class="fa-solid fa-comments fa-fw" target="_self"  href="/" onclick="return false;" title="comment"></a></li>
        
          <li><a id="s-toc" class="s-toc fa-solid fa-list fa-fw" target="_self"  href="/" onclick="return false;" title="toc"></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
            <img no-lazy class='logo' src='https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/Logo-NavBar@3x.png'/>
          
          
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h m-pc'>
          
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/" title="博客"
                  
                  
                  
                    active-action="action-home"
                  >
                  <i class='fa-solid fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/categories/" title="分类"
                  
                  
                  
                    active-action="action-categories"
                  >
                  <i class='fa-solid fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/tags/" title="标签"
                  
                  
                  
                    active-action="action-tags"
                  >
                  <i class='fa-solid fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/archives/" title="归档"
                  
                  
                  
                    active-action="action-archives"
                  >
                  <i class='fa-solid fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/friends/" title="友链"
                  
                  
                  
                    active-action="action-friends"
                  >
                  <i class='fa-solid fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/about/" title="关于"
                  
                  
                  
                    active-action="action-about"
                  >
                  <i class='fa-solid fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
          
				</ul>
			</div>
      
      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fa-solid fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>
      

			<ul class='switcher nav-list-h m-phone'>
				
					<li><a class="s-search fa-solid fa-search fa-fw" target="_self" href="/" onclick="return false;" title="search"></a></li>
				
				<li>
          <a class="s-menu fa-solid fa-bars fa-fw" target="_self" href="/" onclick="return false;" title="menu"></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/" title="博客"
                  
                  
                  
                    active-action="action-home"
                  >
                  <i class='fa-solid fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/categories/" title="分类"
                  
                  
                  
                    active-action="action-categories"
                  >
                  <i class='fa-solid fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/tags/" title="标签"
                  
                  
                  
                    active-action="action-tags"
                  >
                  <i class='fa-solid fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/archives/" title="归档"
                  
                  
                  
                    active-action="action-archives"
                  >
                  <i class='fa-solid fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/friends/" title="友链"
                  
                  
                  
                    active-action="action-friends"
                  >
                  <i class='fa-solid fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/about/" title="关于"
                  
                  
                  
                    active-action="action-about"
                  >
                  <i class='fa-solid fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>

      <!-- Custom Files header begin -->
      
      <!-- Custom Files header end -->
		</div>
	</div>
  </div>
</header>

    <div id="l_body">
      <div id="l_cover">
  
    
      <!-- see: /layout/_partial/scripts/_ctrl/coverCtrl.ejs -->
      <div id="none" class='cover-wrapper post dock' style="display: none;">
        
  <div class='cover-bg lazyload placeholder' data-bg="https://raw.githubusercontent.com/Jav1ki4N/ImgFridge/main/allaboutlily.jpg?token=BEA5E7ZCHW3UXGJAWSO6NA3IXFUKU"></div>

<div class='cover-body'>
  <div class='top'>
    
    
      <p class="title">i4Ns Rabbit Hole</p>
    
    
  </div>
  <div class='bottom'>
    <div class='menu navigation'>
      <div class='list-h'>
        
          
            <a href="/v4/getting-started/"
              
              
              active-action="action-v4getting-started">
              <img src='https://unpkg.com/volantis-static@0.0.1654736714924/media/twemoji/assets/svg/1f5c3.svg'><p>文档</p>
            </a>
          
            <a href="/faqs/"
              
              
              active-action="action-faqs">
              <img src='https://unpkg.com/volantis-static@0.0.1654736714924/media/twemoji/assets/svg/1f516.svg'><p>帮助</p>
            </a>
          
            <a href="/examples/"
              
              
              active-action="action-examples">
              <img src='https://unpkg.com/volantis-static@0.0.1654736714924/media/twemoji/assets/svg/1f396.svg'><p>示例</p>
            </a>
          
            <a href="/contributors/"
              
              
              active-action="action-contributors">
              <img src='https://unpkg.com/volantis-static@0.0.1654736714924/media/twemoji/assets/svg/1f389.svg'><p>社区</p>
            </a>
          
            <a href="/archives/"
              
              
              active-action="action-archives">
              <img src='https://unpkg.com/volantis-static@0.0.1654736714924/media/twemoji/assets/svg/1f4f0.svg'><p>博客</p>
            </a>
          
            <a target="_blank" rel="noopener" href="https://github.com/volantis-x/hexo-theme-volantis/"
              
              
              active-action="action-https:githubcomvolantis-xhexo-theme-volantis">
              <img src='https://unpkg.com/volantis-static@0.0.1654736714924/media/twemoji/assets/svg/1f9ec.svg'><p>源码</p>
            </a>
          
        
      </div>
    </div>
  </div>
</div>

        <div id="scroll-down" style="display: none;"><i class="fa fa-chevron-down scroll-down-effects"></i></div>
      </div>
    
  
</div>

      <div id="safearea">
        <div class="body-wrapper">
          
<div id="l_main" class=''>
  <article itemscope itemtype="http://schema.org/Article" class="article post white-box reveal md shadow floatable blur article-type-post" id="post" itemscope itemprop="blogPost">
  <link itemprop="mainEntityOfPage" href="http://jav1ki4n.github.io/2024/06/14/STM32 SPL Based Note By Ian Javík/">
  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="i4N's Terminal">
  </span>
  <span hidden itemprop="post" itemscope itemtype="http://schema.org/Post">
    <meta itemprop="name" content="i4N's Terminal">
    <meta itemprop="description" content="666">
  </span>
  


  
    <span hidden>
      <meta itemprop="image" content="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png">
    </span>
  
  <div class="article-meta" id="top">
    
    
    
      <h1 class="title" itemprop="name headline">
        STM32 SPL Based Note By Ian Javík
      </h1>
      <div class='new-meta-box'>
        
          
            
<div class='new-meta-item author' itemprop="author" itemscope itemtype="http://schema.org/Person">
  <a itemprop="url" class='author' href="/" rel="nofollow">
    <img itemprop="image" src="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/apple-touch-icon.png" class="lazyload" data-srcset="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/apple-touch-icon.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">
    <p itemprop="name">请设置文章作者</p>
  </a>
</div>

          
        
          
            

          
        
          
            <div class="new-meta-item date" itemprop="dateCreated datePublished" datetime="2024-06-14T00:00:00+08:00">
  <a class='notlink'>
    <i class="fa-solid fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2024年6月14日</p>
  </a>
</div>

          
        
          
            



          
        
        <!-- Custom Files topMeta begin-->
        
        <!-- Custom Files topMeta end-->
      </div>
    
  </div>


  <div id="layoutHelper-page-plugins"></div>
  <div id="post-body" itemprop="articleBody">
    <h1 id="1-STM32F103C8T6-最小系统版"><a href="#1-STM32F103C8T6-最小系统版" class="headerlink" title="1. STM32F103C8T6 最小系统版"></a>1. STM32F103C8T6 最小系统版</h1><h2 id="1-1-SWD-调试接口：下载"><a href="#1-1-SWD-调试接口：下载" class="headerlink" title="1.1 SWD 调试接口：下载"></a>1.1 SWD 调试接口：下载</h2><p><code>SWD</code>（Serial Wire Debug，串行总线调试）接口通常用于调试和编程.</p>
<table>
<thead>
<tr>
<th>引脚</th>
<th>描述</th>
<th>对应ST-LINK V2引脚</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>SWCLK</code> (Serial Wire Clock)</strong></td>
<td><code>SWD</code>时钟线</td>
<td><code>SWCLK</code></td>
</tr>
<tr>
<td><strong><code>SWDIO</code> (Serial Wire Debug I&#x2F;O)</strong></td>
<td><code>SWD</code>数据线，可能标记为<code>SWIO</code></td>
<td><code>SWDIO</code></td>
</tr>
<tr>
<td><strong><code>GND</code> (Ground)</strong></td>
<td>接地线</td>
<td><code>GND</code></td>
</tr>
<tr>
<td><strong><code>3V3</code> (3.3V)</strong></td>
<td>电源引脚，提供3.3V电源</td>
<td><code>3V3</code></td>
</tr>
</tbody></table>
<h2 id="1-2-PC13-引脚：板载LED"><a href="#1-2-PC13-引脚：板载LED" class="headerlink" title="1.2  PC13 引脚：板载LED"></a>1.2  PC13 引脚：板载LED</h2><p>在 STM32 微控制器中，<code>PC13</code> 是指 GPIOC 端口的第 13 个引脚。每个 GPIO 端口（如 GPIOA, GPIOB, GPIOC 等）都有 16 个引脚（从 0 到 15），可以用于各种输入或输出功能。</p>
<p>在很多 STM32 微控制器开发板上，<code>PC13</code> 通常连接到板载的 LED。例如，在广泛使用的 <strong>STM32F103C8T6</strong>（俗称 “Blue Pill”）开发板上，<code>PC13</code> 连接到板载的 <strong>蓝色 LED</strong>。</p>
<p><code>PC13</code> 引脚上的板载 LED 是 STM32 开发板上一个非常有用的调试和指示工具。通过编写代码控制该引脚上的 LED，可以实现多种功能，如<strong>电源状态指示、程序运行指示、故障排除和用户反馈等</strong>。无论是使用标准外设库还是 HAL 库，初始化和控制 <code>PC13</code> 引脚上的 LED 都非常简单和直观。</p>
<h2 id="1-3-PWR-引脚-LED：电源状态指示"><a href="#1-3-PWR-引脚-LED：电源状态指示" class="headerlink" title="1.3 PWR 引脚 - LED：电源状态指示"></a>1.3 PWR 引脚 - LED：电源状态指示</h2><p><code>PC13</code> 引脚旁边的<code>PWR</code> LED指示灯反映了当前的电源状态。当供电正常时，<code>PWR</code> LED 亮起，提供了直观的电源状态反馈。</p>
<h2 id="1-4-BOOT-引脚：启动模式选择"><a href="#1-4-BOOT-引脚：启动模式选择" class="headerlink" title="1.4 BOOT 引脚：启动模式选择"></a>1.4 BOOT 引脚：启动模式选择</h2><p>在 STM32 微控制器中，<code>BOOT0</code> 和 <code>BOOT1</code> 是两个用于选择启动模式的引脚。这两个引脚的状态决定了微控制器在复位时从哪里开始执行代码。不同的启动模式允许微控制器从不同的存储区域（如主 Flash 存储器、系统存储器或 SRAM）启动。</p>
<p><strong>BOOT0</strong> 和 <strong>BOOT1</strong> 引脚的组合用于选择启动模式。以下是常见的引脚配置及其对应的启动模式：</p>
<ol>
<li><strong>BOOT0 &#x3D; 0, BOOT1 &#x3D; 0</strong>：启动自用户 Flash 存储器。</li>
<li><strong>BOOT0 &#x3D; 1, BOOT1 &#x3D; 0</strong>：启动自系统存储器。</li>
<li><strong>BOOT0 &#x3D; 0, BOOT1 &#x3D; 1</strong>：启动自嵌入式 SRAM。</li>
<li><strong>BOOT0 &#x3D; 1, BOOT1 &#x3D; 1</strong>：启动模式与特定的 STM32 器件相关，但通常也是从系统存储器启动。</li>
</ol>
<p>在实际开发板上，BOOT引脚通常为黄色的一对三头引脚，使用跳线帽根据左右标号“1”或者“0”短接引脚来配置启动模式。一般情况下默认以 <code>启动自用户 Flash 存储器</code> 方式启动。</p>
<hr>
<h1 id="2-新建工程"><a href="#2-新建工程" class="headerlink" title="2. 新建工程"></a>2. 新建工程</h1><p>新建一个STM32工程时，需要在项目文件夹下手动添加以下文件：</p>
<ol>
<li><code>Library</code> 文件夹：存放 <strong>标准库函数</strong></li>
<li><code>StartUp</code> 文件夹：存放项目的 <strong>启动文件</strong></li>
<li><code>User</code> 文件夹：存放用户编写函数以及 <strong>必需头文件</strong></li>
</ol>
<p>Keil 中，需要在 <code>C/C++</code>选项中<code>Include Path</code>下配置头文件路径（即以上的三个文件夹），同时在<code>Define</code>一栏需要填入字符串<code>USE_STDPERIPH_DRIVER</code> 以启用标准库函数的调用。</p>
<p>STM32的编程环境支持的 ARM 编译器至多到 5.06 版本。</p>
<hr>
<h1 id="3-配置寄存器点亮-PC13-上的板载-LED"><a href="#3-配置寄存器点亮-PC13-上的板载-LED" class="headerlink" title="3. 配置寄存器点亮 PC13 上的板载 LED"></a>3. 配置寄存器点亮 PC13 上的板载 LED</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Control the LED at pin PC13*/</span></span><br><span class="line"><span class="comment">/*       Register Based       */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC-&gt;APB2ENR = <span class="number">0x00000010</span>; <span class="comment">// Enable IOPCEN (I/O port C clock enable))</span></span><br><span class="line">	                           <span class="comment">// All GPIO is connected to APB2 bus</span></span><br><span class="line">	</span><br><span class="line">    GPIOC-&gt;CRH = <span class="number">0x00300000</span>; <span class="comment">// GPIO port C high pin(8-15)</span></span><br><span class="line">	                         <span class="comment">// CNF13 (pin 13 config) Push–pull output</span></span><br><span class="line">	                         <span class="comment">// MODE13 (pin 13 mode) output,50hz</span></span><br><span class="line">	</span><br><span class="line">	GPIOC-&gt;ODR = <span class="number">0x00000000</span>; <span class="comment">// GPIO port C Output Data Register</span></span><br><span class="line">	                         <span class="comment">// ODR13(pin 13) set to 0 --&gt; LED on</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">		</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 STM32F103C8T6 微控制器的开发中，<code>#include &quot;stm32f10x.h&quot;</code> 是一种常见的头文件包含方式，用于引入整个 STM32F10x 系列的 <strong>外设库</strong> 。这个头文件包含了 <strong>所有必要的定义</strong>、<strong>声明</strong> 和 <strong>库函数</strong>，使用户可以方便地进行 STM32F10x 系列微控制器的开发。</p>
<p>值得注意的是如前文所提，必须在Keil<code>C/C++</code>的<code>Define</code>添加字符串<code>USE_STDPERIPH_DRIVER</code>才能够正常调用库函数。</p>
<p><code>PC13</code> 上的板载LED由 <code>GPIOC</code>(即为<code>GPIO</code>外设的<code>C</code>端口) 控制，而想要控制 <code>GPIOC</code>，则需要先控制 <code>RCC</code>寄存器上的<code>APB2</code>总线，因为<code>GPIO</code>外设都挂载在<code>APB2</code>总线上。</p>
<p>控制<code>APB2</code>总线，首先需要启用<code>APB2</code>总线的时钟，这个操作可以由控制寄存器<code>APB2ENR</code>实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RCC-&gt;APB2ENR = <span class="number">0x00000010</span>;</span><br></pre></td></tr></table></figure>

<p> 这语句表示将<code>APBENR</code>上的<code>IOPCEN</code>置位 (set bit), 而其他位复位 (reset bit), 这样就完成了 <code>GPIOC</code>时钟使能。当然这里的做法比较直观，没有用逻辑运算来确保其他位不受影响。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIOC-&gt;CRH = <span class="number">0x00300000</span></span><br></pre></td></tr></table></figure>

<p>这语句表示选中<code>GPIOC</code>的高八位（8-15）引脚寄存器<code>CRH</code>，并将 <code>PIN13</code>对应的两个位<code>CNF13</code>,即<code>config13</code>位配置为 <strong>推挽输出</strong>（Push-Pull Output）<code>MODE13</code>位配置为 输出模式(Output) ,速度（Speed）为50Mhz。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIOC-&gt;ODR = <span class="number">0x00000000</span></span><br></pre></td></tr></table></figure>

<p>外设时钟使能以及引脚的输出模式已经配置好，接下来需要提供具体的输出数据了，选中数据输出寄存器<code>ODR</code>,令位<code>pin13</code>复位，其他位也复位，PC13上的LED处于低电，点亮。</p>
<p>实际情况下，使用寄存器配置很麻烦，所以通常使用标准库函数进行配置。</p>
<h1 id="4-使用标准库函数点亮-PC13-上的板载-LED"><a href="#4-使用标准库函数点亮-PC13-上的板载-LED" class="headerlink" title="4. 使用标准库函数点亮 PC13 上的板载 LED"></a>4. 使用标准库函数点亮 PC13 上的板载 LED</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE); <span class="comment">//Operate APB2 bus Clock</span></span><br><span class="line">	                                                     <span class="comment">//Object:GPIO C port</span></span><br><span class="line">	                                                     <span class="comment">//New State: ENABLE</span></span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">// define GPIO Init Structure</span></span><br><span class="line">	                                     <span class="comment">// the structure contains GPIO Init info</span></span><br><span class="line">	</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; <span class="comment">//Mode: Output;Push-Pull</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13; <span class="comment">//Pin:13</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<span class="comment">//Speed:50Mhz</span></span><br><span class="line">	</span><br><span class="line">	GPIO_Init(GPIOC,&amp;GPIO_InitStructure); <span class="comment">//Info is provided </span></span><br><span class="line">	                                      <span class="comment">//Ready to init GPIO</span></span><br><span class="line">	</span><br><span class="line">	GPIO_SetBits(GPIOC,GPIO_Pin_13); <span class="comment">//GPIO Port:C</span></span><br><span class="line">	                                 <span class="comment">//Pin:13</span></span><br><span class="line">	                                 <span class="comment">//State:1</span></span><br><span class="line">	                                 <span class="comment">//The PC13 LED will turn off then</span></span><br><span class="line">	</span><br><span class="line">	GPIO_ResetBits(GPIOC,GPIO_Pin_13);<span class="comment">//GPIO Port:C</span></span><br><span class="line">	                                  <span class="comment">//Pin:13</span></span><br><span class="line">	                                  <span class="comment">//State:0</span></span><br><span class="line">	                                  <span class="comment">//The PC13 LED will light up then</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-1-APB2时钟使能函数"><a href="#4-1-APB2时钟使能函数" class="headerlink" title="4.1 APB2时钟使能函数"></a>4.1 APB2时钟使能函数</h2><p><code>RCC_APB2PeriphClockCmd</code> 是一个宏函数，用于启用或禁用外设在 APB2 总线上的时钟。它是 STM32 标准外设库（Standard Peripheral Library）的一部分。启用时钟是使用 STM32 外设（如 GPIO、USART、ADC 等）之前的必要步骤，因为在时钟被启用之前，这些外设不会工作。</p>
<h3 id="4-1-1-函数原型"><a href="#4-1-1-函数原型" class="headerlink" title="4.1.1 函数原型"></a>4.1.1 函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RCC_APB2PeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_APB2Periph, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="4-1-2-参数解释"><a href="#4-1-2-参数解释" class="headerlink" title="4.1.2 参数解释"></a>4.1.2 参数解释</h3><p><code>RCC_APB2Periph</code>为<code>uint32_t</code>类型参数：指定要启用或禁用的 APB2 外设时钟。可以是以下值之一：</p>
<pre><code>- `RCC_APB2Periph_AFIO`：Alternate Function I/O 时钟
- `RCC_APB2Periph_GPIOA`：GPIOA 时钟
- `RCC_APB2Periph_GPIOB`：GPIOB 时钟
- `RCC_APB2Periph_GPIOC`：GPIOC 时钟
- `RCC_APB2Periph_GPIOD`：GPIOD 时钟
- `RCC_APB2Periph_GPIOE`：GPIOE 时钟
- `RCC_APB2Periph_ADC1`：ADC1 时钟
- `RCC_APB2Periph_ADC2`：ADC2 时钟
- `RCC_APB2Periph_TIM1`：TIM1 时钟
- `RCC_APB2Periph_SPI1`：SPI1 时钟
- `RCC_APB2Periph_USART1`：USART1 时钟
etc.
</code></pre>
<p><code>NewState</code>为<code>Function State</code>枚举类型参数：指定使能或禁用状态，可以是以下值之一：</p>
<pre><code>- `ENABLE`：启用指定外设的时钟
- `DISABLE`：禁用指定外设的时钟
</code></pre>
<p>此处需要开启GPIOC的时钟，所以调用如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE);</span><br></pre></td></tr></table></figure>

<h2 id="4-2-GPIO配置初始化信息"><a href="#4-2-GPIO配置初始化信息" class="headerlink" title="4.2 GPIO配置初始化信息"></a>4.2 GPIO配置初始化信息</h2><h3 id="4-2-1-声明结构体变量"><a href="#4-2-1-声明结构体变量" class="headerlink" title="4.2.1 声明结构体变量"></a>4.2.1 声明结构体变量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br></pre></td></tr></table></figure>

<p>结构体类型的具体组成（已预定义）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint16_t</span> GPIO_Pin;              </span><br><span class="line">  GPIOSpeed_TypeDef GPIO_Speed;   </span><br><span class="line">  GPIOMode_TypeDef GPIO_Mode;     </span><br><span class="line">&#125; GPIO_InitTypeDef;</span><br></pre></td></tr></table></figure>

<p>声明类型为 <code>GPIO_InitTypeDef</code> 的结构体变量<code>GPIO_InitStructure</code>，这个结构体的成员包括 GPIO模式<code>GPIO_InitStructure.GPIO_Mode</code>，GPIO引脚 <code>GPIO_InitStructure.GPIO_Pin</code> 和GPIO速度 <code>GPIO_InitStructure.GPIO_Speed</code>.</p>
<p>这个结构体包含了GPIO初始化所需要的信息。</p>
<h3 id="4-2-2-初始化结构体"><a href="#4-2-2-初始化结构体" class="headerlink" title="4.2.2 初始化结构体"></a>4.2.2 初始化结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; <span class="comment">//Mode: Output;Push-Pull</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13; <span class="comment">//Pin:13</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<span class="comment">//Speed:50Mhz</span></span><br></pre></td></tr></table></figure>

<p>其中<code>GPIO_Mode_Out_PP</code>,<code>GPIO_Pin_13</code>,<code>GPIO_Speed_50MHz</code>都是预定义的字符串，整体配置的效果为通过 GPIOC Pin 13引脚以 50Mhz 的速度进行推挽输出。</p>
<h2 id="4-3-初始化GPIO"><a href="#4-3-初始化GPIO" class="headerlink" title="4.3 初始化GPIO"></a>4.3 初始化GPIO</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO_Init(GPIOC,&amp;GPIO_InitStructure);</span><br></pre></td></tr></table></figure>

<p>函数<code>GPIO_Init()</code>的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Init</span><span class="params">(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)</span>;</span><br></pre></td></tr></table></figure>

<p>入口参数为两个指针，第一个指向端口 GPIOx，在具体填写时这里就填写为了<code>GPIOC</code>以驱动GPIO的C端口。而第二个指针指向这个端口的启动配置，也就是承载启动信息的结构体<code>GPIO_InitStructure</code>,由于是结构体，需要加上<code>&amp;</code>取地址符号，所以这里具体填写的是<code>&amp;GPIO_InitStructure</code>.</p>
<h2 id="4-4-GPIO输出数据"><a href="#4-4-GPIO输出数据" class="headerlink" title="4.4 GPIO输出数据"></a>4.4 GPIO输出数据</h2><p>GPIO已经启动完成，但是没有具体的输出数据，所以PC13板载LED不会有任何反应。</p>
<p>这时候需要用到一对函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GPIO_SetBits</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_ResetBits</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;</span><br></pre></td></tr></table></figure>

<p>两个函数的入口参数都是指向GPIO端口的指针，以及对应的引脚。</p>
<p><code>GPIO_Setbits</code>为置位引脚，即置高电平，而<code>GPIO_Resetbits</code>则复位引脚，即置低电平。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO_ResetBits(GPIOC,GPIO_Pin_13);</span><br></pre></td></tr></table></figure>

<p>比如这样，对 PC13 引脚复位，那么板载LED就会因为低电平而被点亮，反之如果置位为很高电平，PC13 就不会被点亮。</p>
<h2 id="4-5-总结"><a href="#4-5-总结" class="headerlink" title="4.5 总结"></a>4.5 总结</h2><p>点亮一个板载LED的步骤有以下几步：</p>
<ol>
<li>使能外设时钟（位于APB2总线上）</li>
<li>通过GPIO结构体配置GPIO初始化信息</li>
<li>初始化GPIO</li>
<li>配置GPIO的输出数据</li>
</ol>
<h1 id="5-GPIO-输出"><a href="#5-GPIO-输出" class="headerlink" title="5. GPIO 输出"></a>5. GPIO 输出</h1><h2 id="5-1-什么是GPIO"><a href="#5-1-什么是GPIO" class="headerlink" title="5.1 什么是GPIO"></a>5.1 什么是GPIO</h2><p>GPIO（<strong>General-Purpose Input&#x2F;Output</strong>，通用输入&#x2F;输出）是一种能够在设备（如微控制器或单板计算机）与外部设备（如传感器、LED、按键等）之间进行数字信号通信的接口。GPIO引脚可以配置为输入模式或输出模式：</p>
<ul>
<li><strong>输入模式</strong>：GPIO引脚用于读取外部设备的信号，例如按键的状态或传感器的数据。</li>
<li><strong>输出模式</strong>：GPIO引脚用于向外部设备发送信号，例如控制LED的亮灭或驱动其他外设。</li>
</ul>
<p>GPIO引脚的特点是灵活多用，用户可以根据需要通过编程来配置和使用这些引脚。这些引脚通常在嵌入式系统开发和电子项目中广泛应用。</p>
<h2 id="5-2-GPIO特征"><a href="#5-2-GPIO特征" class="headerlink" title="5.2 GPIO特征"></a>5.2 GPIO特征</h2><p>GPIO（通用输入&#x2F;输出）引脚的主要特征包括：</p>
<ol>
<li><p><strong>双向性</strong>：GPIO引脚可以配置为输入模式或输出模式，以适应不同的应用需求。</p>
</li>
<li><p><strong>可编程性</strong>：用户可以通过软件编程来设置GPIO引脚的功能和状态，例如设置引脚为高电平或低电平。</p>
</li>
<li><p><strong>中断功能</strong>：许多GPIO引脚支持中断，当引脚的状态发生变化时，可以触发中断处理程序，提高响应速度和效率。</p>
</li>
<li><p><strong>电气特性</strong>：</p>
<ul>
<li><p><strong>电压等级</strong>：不同设备的GPIO引脚支持不同的工作电压，一般为3.3V。部分<sup>1</sup>可容忍5V（也就是可以输入5v电压作为高电平而不需要经过转换芯片）。输出一般则只有3.3V，因为供电最该就只能达到3.3V</p>
</li>
<li><p><strong>电流驱动能力</strong>：GPIO引脚能驱动一定的电流，用于控制外部设备，但通常电流有限，需要外部驱动器或缓冲器。</p>
</li>
</ul>
</li>
<li><p><strong>复用功能</strong>：某些GPIO引脚可以复用为其他外设的引脚，例如UART、I2C、SPI等通讯接口，通过复用功能，可以减少引脚数量，提高资源利用率。</p>
</li>
<li><p><strong>上拉&#x2F;下拉电阻</strong>：GPIO引脚通常内置上拉或下拉电阻，用于确保引脚在未连接时保持稳定的高电平或低电平状态，防止悬空引脚导致不稳定的输入状态。</p>
</li>
<li><p><strong>数字信号处理</strong>：GPIO引脚主要处理数字信号，即高（1）和低（0）两种状态，适用于数字输入和输出操作。</p>
</li>
</ol>
<hr>
<p><sup>1</sup>: 标有 <strong>FT</strong> （5V Tolerate）字样的引脚</p>
<h2 id="5-3-输出模式"><a href="#5-3-输出模式" class="headerlink" title="5.3 输出模式"></a>5.3 输出模式</h2><h3 id="5-3-1-推挽输出-（强输出）"><a href="#5-3-1-推挽输出-（强输出）" class="headerlink" title="5.3.1 推挽输出 （强输出）"></a>5.3.1 推挽输出 （强输出）</h3><p><strong>推挽输出</strong>（Push-Pull Output）是GPIO引脚的一种输出模式，常用于驱动外部负载，如LED、继电器等。推挽输出的主要特点和优点包括：</p>
<ol>
<li><p><strong>双向驱动能力</strong>：推挽输出配置中，GPIO引脚可以在输出高电平和低电平之间切换。它包含两个晶体管，一个连接到电源，另一个连接到地，通过交替导通来提供强大的驱动能力。</p>
</li>
<li><p><strong>低功耗</strong>：由于推挽输出通过晶体管切换来驱动负载，在切换过程中消耗的功率较低，有助于节省能源。</p>
</li>
<li><p><strong>高驱动电流</strong>：推挽输出能够提供较大的电流，适合驱动需要较高电流的负载，如大功率LED或电动机。</p>
</li>
<li><p><strong>快速响应</strong>：推挽输出模式下，电平切换速度快，适合需要快速响应的应用，如高频率开关和信号传输。</p>
</li>
</ol>
<p>推挽输出的电路示例如下图所示：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">        +Vcc</span><br><span class="line">         |</span><br><span class="line">         |</span><br><span class="line">         |</span><br><span class="line">        <span class="comment">---</span></span><br><span class="line">       |   |</span><br><span class="line">       |   |</span><br><span class="line">       |<span class="comment">---|</span></span><br><span class="line">       |   |</span><br><span class="line">       |   |</span><br><span class="line">       |<span class="comment">---|</span></span><br><span class="line">         |</span><br><span class="line">GPIO <span class="comment">----+---- Load</span></span><br><span class="line">         |</span><br><span class="line">       |   |</span><br><span class="line">       |<span class="comment">---|</span></span><br><span class="line">       |   |</span><br><span class="line">       |<span class="comment">---|</span></span><br><span class="line">         |</span><br><span class="line">         |</span><br><span class="line">        GND</span><br></pre></td></tr></table></figure>

<p>在这种配置下，GPIO引脚可以通过控制上面的晶体管导通（输出高电平）或关闭（输出低电平），来实现负载的开关控制。STM32对IO口具有绝对控制权。</p>
<h3 id="5-3-2-开漏输出"><a href="#5-3-2-开漏输出" class="headerlink" title="5.3.2 开漏输出"></a>5.3.2 开漏输出</h3><p><strong>开漏输出</strong>（Open-Drain Output，也称为Open-Collector Output）是GPIO引脚的一种输出模式，常用于需要多个设备共享一个信号线的场合，例如I2C总线或多设备中断线。开漏输出的主要特点和优点包括：</p>
<ol>
<li><p><strong>单向驱动能力</strong>：在开漏配置中，GPIO引脚只能拉低到地（输出低电平），不能主动拉高到电源电平（高电平）。为了实现高电平，需要外部上拉电阻连接到电源。</p>
</li>
<li><p><strong>上拉电阻</strong>：由于开漏输出无法主动输出高电平，所以需要在信号线上添加一个上拉电阻，这样当开漏引脚处于高阻态时（即不拉低），信号线通过上拉电阻被拉高到电源电平。</p>
</li>
<li><p><strong>线与逻辑</strong>：开漏输出允许多个开漏引脚连接到同一信号线上，通过“线与”逻辑实现信号共享。当任一引脚拉低时，信号线被拉低；只有当所有引脚都处于高阻态时，信号线才被上拉电阻拉高。</p>
</li>
<li><p><strong>适合长线驱动</strong>：由于开漏输出可以有效避免总线冲突，适合在长线或多设备通信的场合使用，如I2C总线、RS-485等。</p>
</li>
</ol>
<p>开漏输出的电路示例如下图所示：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">        +Vcc</span><br><span class="line">         |</span><br><span class="line">         |</span><br><span class="line">      Rpull-up</span><br><span class="line">         |</span><br><span class="line">GPIO <span class="comment">----+---- Signal Line</span></span><br><span class="line">         |</span><br><span class="line">       |<span class="comment">---|</span></span><br><span class="line">       |   |</span><br><span class="line">       |   |</span><br><span class="line">       |<span class="comment">---|</span></span><br><span class="line">         |</span><br><span class="line">        GND</span><br></pre></td></tr></table></figure>

<p>在这种配置下：</p>
<ul>
<li>当GPIO引脚输出低电平时，信号线被拉低到低电平。</li>
<li>当GPIO引脚处于高阻态时，信号线通过上拉电阻Rpull-up被拉高到电源电平</li>
<li><strong>避免总线冲突</strong>：适用于多个设备共享一条信号线的情况，避免多个设备同时驱动信号线导致的冲突。</li>
<li><strong>简单电路设计</strong>：在多设备通信中，开漏输出配置简单，易于实现。</li>
<li><strong>多设备兼容性</strong>：适用于需要不同设备共用一条总线的应用，如I2C、1-Wire等通信协议。</li>
<li><strong>I2C总线</strong>：I2C总线采用开漏输出模式，多设备通过共享SDA和SCL线进行通信，上拉电阻确保信号线在空闲时处于高电平状态。</li>
<li><strong>多设备中断线</strong>：在多设备系统中，各设备可以将自己的中断引脚配置为开漏输出，共享一个中断信号线。</li>
</ul>
<p>总结来说，开漏输出是GPIO引脚的一种常见模式，特别适合需要多个设备共享信号线的应用场景，通过上拉电阻确保信号线在空闲时保持高电平。</p>
<h2 id="5-4-GPIO的工作模式"><a href="#5-4-GPIO的工作模式" class="headerlink" title="5.4 GPIO的工作模式"></a>5.4 GPIO的工作模式</h2><table>
<thead>
<tr>
<th>工作模式</th>
<th>类型</th>
<th>特征</th>
</tr>
</thead>
<tbody><tr>
<td>浮空输入</td>
<td>数字输入</td>
<td>引脚悬空时输入电平不确定</td>
</tr>
<tr>
<td>上拉输入</td>
<td>数字输入</td>
<td>内接上拉电阻，悬空默认高电平</td>
</tr>
<tr>
<td>下拉输入</td>
<td>数字输入</td>
<td>内接下拉电阻，悬空默认低电平</td>
</tr>
<tr>
<td>模拟输入</td>
<td>模拟输入</td>
<td>GPIO无效，引脚直接接入内部ADC</td>
</tr>
<tr>
<td>开漏输出</td>
<td>数字输出</td>
<td>高电平为高阻态，低电平接VSS输出低电平</td>
</tr>
<tr>
<td>推挽输出</td>
<td>数字输出</td>
<td>高电平接VDD输出高电平，低电平接VSS输出低电平</td>
</tr>
<tr>
<td>复用开漏输出</td>
<td>数字输出</td>
<td>同上，但由片上外设控制</td>
</tr>
<tr>
<td>复用推挽输出</td>
<td>数字输出</td>
<td>同上，但由片上外设控制</td>
</tr>
</tbody></table>
<h1 id="6-基本的-GPIO-输出函数"><a href="#6-基本的-GPIO-输出函数" class="headerlink" title="6. 基本的 GPIO 输出函数"></a>6. 基本的 GPIO 输出函数</h1><h2 id="6-1-GPIO-SetBits-ResetBits"><a href="#6-1-GPIO-SetBits-ResetBits" class="headerlink" title="6.1 GPIO_SetBits &#x2F; ResetBits"></a>6.1 GPIO_SetBits &#x2F; ResetBits</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GPIO_SetBits</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_ResetBits</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;</span><br></pre></td></tr></table></figure>

<p>首先是上文已经提及的两个函数，分别单独置位和复位。</p>
<p>可以使用或运算符来同时控制多个位的输出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO_SetBits(GPIOA,GPIO_Pin0 | GPIO_Pin_1);</span><br></pre></td></tr></table></figure>

<h2 id="6-2-GPIO-WriteBit"><a href="#6-2-GPIO-WriteBit" class="headerlink" title="6.2 GPIO_WriteBit"></a>6.2 GPIO_WriteBit</h2><p>如果需要用一个函数来完成置位和复位，考虑下面的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GPIO_WriteBit</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin, BitAction BitVal)</span>;</span><br></pre></td></tr></table></figure>

<p>函数<code>GPIO_WriteBit</code>的入口参数有三个，相比上面的一对函数，这个函数的前两个入口参数相同，都是选中GPIO端口以及选中位，不同之处在于第三个端口可根据具体值来决定置位还是复位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GPIO_WriteBit(GPIOA,GPIO_Pin_0,Bit_SET);</span><br><span class="line">GPIO_WriteBit(GPIOA,GPIO_Pin_0,Bit_RESET);</span><br></pre></td></tr></table></figure>

<p>如图所示，字符串<code>Bit_RESET</code>和<code>Bit_SET</code>就表示对选中的位置位 &#x2F; 复位。</p>
<p>当然也可以使用强制类型转换来替换成更直观的 0 和 1，比如是：<br><code>(BitAction)0</code>与<code>(BitAction)1</code></p>
<h1 id="7-GPIO输出-以流水灯为例"><a href="#7-GPIO输出-以流水灯为例" class="headerlink" title="7. GPIO输出 - 以流水灯为例"></a>7. GPIO输出 - 以流水灯为例</h1><h2 id="7-1-同时初始化多个引脚"><a href="#7-1-同时初始化多个引脚" class="headerlink" title="7.1 同时初始化多个引脚"></a>7.1 同时初始化多个引脚</h2><p>假设多个引脚所需要的初始化信息都是一样的，那只需要一个结构体变量进行描述就可以了，只是<code>GPIO_Initstructure.GPIo.Pin</code>的具体值需要变更。</p>
<p>假如需要同时启动引脚 PA0 - PA2</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO_Initstructure.GPIo.Pin = GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_2</span><br></pre></td></tr></table></figure>

<p>按位或可以实现对多个引脚的全部选中。这是因为按位或的结果等效为同时选中多个引脚。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#define GPIO_Pin_0                 ((uint16_t)0x0001)  /*!&lt; Pin 0 selected */</span><br><span class="line">#define GPIO_Pin_1                 ((uint16_t)0x0002)  /*!&lt; Pin 1 selected */</span><br><span class="line">#define GPIO_Pin_2                 ((uint16_t)0x0004)  /*!&lt; Pin 2 selected */</span><br><span class="line">#define GPIO_Pin_3                 ((uint16_t)0x0008)  /*!&lt; Pin 3 selected */</span><br><span class="line">#define GPIO_Pin_4                 ((uint16_t)0x0010)  /*!&lt; Pin 4 selected */</span><br><span class="line">#define GPIO_Pin_5                 ((uint16_t)0x0020)  /*!&lt; Pin 5 selected */</span><br><span class="line">#define GPIO_Pin_6                 ((uint16_t)0x0040)  /*!&lt; Pin 6 selected */</span><br><span class="line">#define GPIO_Pin_7                 ((uint16_t)0x0080)  /*!&lt; Pin 7 selected */</span><br><span class="line">#define GPIO_Pin_8                 ((uint16_t)0x0100)  /*!&lt; Pin 8 selected */</span><br><span class="line">#define GPIO_Pin_9                 ((uint16_t)0x0200)  /*!&lt; Pin 9 selected */</span><br><span class="line">#define GPIO_Pin_10                ((uint16_t)0x0400)  /*!&lt; Pin 10 selected */</span><br><span class="line">#define GPIO_Pin_11                ((uint16_t)0x0800)  /*!&lt; Pin 11 selected */</span><br><span class="line">#define GPIO_Pin_12                ((uint16_t)0x1000)  /*!&lt; Pin 12 selected */</span><br><span class="line">#define GPIO_Pin_13                ((uint16_t)0x2000)  /*!&lt; Pin 13 selected */</span><br><span class="line">#define GPIO_Pin_14                ((uint16_t)0x4000)  /*!&lt; Pin 14 selected */</span><br><span class="line">#define GPIO_Pin_15                ((uint16_t)0x8000)  /*!&lt; Pin 15 selected */</span><br><span class="line">#define GPIO_Pin_All               ((uint16_t)0xFFFF)  /*!&lt; All pins selected */</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如图所示，<code>GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_2</code>的结果就是<code>0001|0002|0004</code>,转成二进制就是<code>0000 0000 0000 0001|0000 0000 0000 0010|0000 0000 0000 0100 = 0000 0000 0000 00111</code>,这个结果代表的就是Pin 0 - 2 都被选中了。</p>
<p>假如需要初始化全部引脚，可知对应<code>1111 1111 1111 1111</code>,即十六进制下的<code>0xffff</code>，定义为字符串<code>GPIO_Pin_All</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; <span class="comment">//Mode: Output;Push-Pull</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All; <span class="comment">//Pin:All</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<span class="comment">//Speed:50Mhz</span></span><br></pre></td></tr></table></figure>

<p>配置完成。</p>
<h2 id="7-2-GPIO-Write"><a href="#7-2-GPIO-Write" class="headerlink" title="7.2 GPIO_Write"></a>7.2 GPIO_Write</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Write</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> PortVal)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIOx-&gt;ODR = PortVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO_Write(GPIOA,~<span class="number">0x0001</span>);</span><br></pre></td></tr></table></figure>

<p> 函数<code>GPIO_Write</code>允许对GPIO端口所有位同时进行控制。</p>
<p>参数<code>PortVal</code>是对数据内存寄存器<code>GPIOx-&gt;ODR</code>的映射，所以允许直接写十六进制代码来表示端口上所有位的状态.</p>
<h2 id="7-4-循环移位控制引脚状态"><a href="#7-4-循环移位控制引脚状态" class="headerlink" title="7.4 循环移位控制引脚状态"></a>7.4 循环移位控制引脚状态</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> cnt = <span class="number">0</span>; cnt &lt; <span class="number">5</span>; cnt++) <span class="comment">//for loop for creating flow</span></span><br><span class="line">&#123;</span><br><span class="line">	Delay_ms(<span class="number">500</span>); <span class="comment">// the duration of each flicker</span></span><br><span class="line">	GPIO_Write(GPIOA, ~(<span class="number">0x0001</span> &lt;&lt; cnt)); <span class="comment">// left shift to the cnt.th pin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>0x0001&lt;&lt;1</code>表示将端口状态从<code>0x0001</code>,即只有pin0输出高电平，左移1位，就是变成<code>0000 0000 0000 0001 -&gt; 0000 0000 0000 0010</code>,在十六进制下表示为<code>0x0002</code>.</p>
<p>在这之后对整体取反，因为LED是低电平点亮的。</p>
<p>那么将上述方法放入for循环里面，改成<code>~(0x0001 &lt;&lt; cnt)</code>就可以使得引脚按顺序输出高电平，再取反就可以实现LED按顺序亮起了.</p>
<h1 id="8-GPIO输入-以按键控制为例"><a href="#8-GPIO输入-以按键控制为例" class="headerlink" title="8.GPIO输入 - 以按键控制为例"></a>8.GPIO输入 - 以按键控制为例</h1><p>通过按键控制 LED 的亮灭，就是外部操作向 GPIO 输入数据。</p>
<h2 id="8-1-GPIO-输入模式"><a href="#8-1-GPIO-输入模式" class="headerlink" title="8.1 GPIO 输入模式"></a>8.1 GPIO 输入模式</h2><h3 id="8-1-1-上拉输入"><a href="#8-1-1-上拉输入" class="headerlink" title="8.1.1 上拉输入"></a>8.1.1 上拉输入</h3><p>上拉输入是一种 GPIO（通用输入输出）引脚配置模式，用于微控制器和其他集成电路。在上拉输入模式下，引脚通过一个内部或外部上拉电阻连接到高电平（通常是电源电压）。这种配置确保在引脚未连接（浮空）或开关未闭合时，输入引脚的电平是高电平，而不是不确定的浮动状态。</p>
<p>上拉输入的用途：</p>
<ol>
<li><p><strong>防止浮动电平</strong>：在数字电路中，未连接的输入引脚可能处于不确定的浮动状态，这会导致电路不稳定或误触发。上拉电阻确保引脚在未驱动时处于已知的高电平状态。</p>
</li>
<li><p><strong>按钮&#x2F;开关输入</strong>：当使用按钮或开关作为输入时，通常会使用上拉电阻。按钮未按下时，输入引脚通过上拉电阻保持高电平；按下按钮时，引脚被拉到低电平。</p>
</li>
</ol>
<p>上拉输入的工作原理：</p>
<ol>
<li><p>当引脚配置为上拉输入时，如果没有外部连接，引脚会通过上拉电阻连接到高电平，读到的电平为高。</p>
</li>
<li><p>当引脚连接到低电平时（例如通过按下按钮），电流通过上拉电阻流向地，读到的电平为低。</p>
</li>
</ol>
<h3 id="8-1-2-下拉输入"><a href="#8-1-2-下拉输入" class="headerlink" title="8.1.2 下拉输入"></a>8.1.2 下拉输入</h3><p>下拉输入是另一种 GPIO（通用输入输出）引脚配置模式，用于微控制器和其他集成电路。在下拉输入模式下，引脚通过一个内部或外部下拉电阻连接到低电平（通常是地）。这种配置确保在引脚未连接（浮空）或开关未闭合时，输入引脚的电平是低电平，而不是不确定的浮动状态。</p>
<p>下拉输入的用途：</p>
<ol>
<li><p><strong>防止浮动电平</strong>：类似于上拉电阻，下拉电阻也防止输入引脚在未连接时处于不确定的浮动状态，这会导致电路不稳定或误触发。下拉电阻确保引脚在未驱动时处于已知的低电平状态。</p>
</li>
<li><p><strong>按钮&#x2F;开关输入</strong>：当使用按钮或开关作为输入时，有时需要用下拉电阻。按钮未按下时，输入引脚通过下拉电阻保持低电平；按下按钮时，引脚被拉到高电平。</p>
</li>
</ol>
<p>下拉输入的工作原理：</p>
<ul>
<li>当引脚配置为下拉输入时，如果没有外部连接，引脚会通过下拉电阻连接到低电平，读到的电平为低。</li>
<li>当引脚连接到高电平时（例如通过按下按钮），电流通过下拉电阻流向高电平源，读到的电平为高。</li>
</ul>
<h3 id="8-1-3-其他输入模式"><a href="#8-1-3-其他输入模式" class="headerlink" title="8.1.3 其他输入模式"></a>8.1.3 其他输入模式</h3><ul>
<li><strong>浮动输入</strong>：未连接时状态不确定。</li>
<li><strong>模拟输入</strong>：用于连接模拟信号。</li>
<li><strong>外部中断输入</strong>：用于触发中断。</li>
</ul>
<h2 id="8-2-预期功能"><a href="#8-2-预期功能" class="headerlink" title="8.2 预期功能"></a>8.2 预期功能</h2><p>两个按键分别接入引脚 <code>PA0</code> 与 <code>PA1</code>，红色LED（LED1）和蓝色LED（LED2）分别接入引脚<code>PA5</code> 和<code>PA7</code>。</p>
<p>当按下连接至引脚<code>PA1</code>的按键时候，LED1亮起，当再次按下时，LED1熄灭。其他一组遵循同样的操作逻辑，两者互不干扰。</p>
<h2 id="8-3-主函数"><a href="#8-3-主函数" class="headerlink" title="8.3 主函数"></a>8.3 主函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GPIO_Init.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ON <span class="string">&quot;ON&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OFF <span class="string">&quot;OFF&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_Set();</span><br><span class="line">	Key_Set();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		Key_Logic();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>GPIO_Set</code>和<code>Key_Set</code>表示两个自定义的初始化函数，分别是LED以及按键的GPIO初始化。while循环中循环执行按键行为函数<code>Key_Logic()</code>。</p>
<h2 id="8-4-相关函数"><a href="#8-4-相关函数" class="headerlink" title="8.4 相关函数"></a>8.4 相关函数</h2><p>按键相关函数封装在<code>Key.h</code>头文件当中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GPIO_Init.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ON <span class="string">&quot;ON&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OFF <span class="string">&quot;OFF&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> indicator1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> indicator2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Set</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE); <span class="comment">//enable apb2 clock</span></span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">// structure def &amp; info </span></span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_2; <span class="comment">//pull-up input</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitStructure); <span class="comment">// gpio init</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Key_Num</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> kn = <span class="number">9</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(!(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0)))</span><br><span class="line">	&#123;</span><br><span class="line">		Delay_ms(<span class="number">20</span>);</span><br><span class="line">		<span class="keyword">while</span>(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0) == <span class="number">0</span>)</span><br><span class="line">		Delay_ms(<span class="number">20</span>);</span><br><span class="line">		<span class="keyword">if</span>(indicator1)&#123;indicator1 = <span class="number">0</span>;kn = <span class="number">1</span>;&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;indicator1 = <span class="number">1</span>;kn = <span class="number">0</span>;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_2)))</span><br><span class="line">	&#123;</span><br><span class="line">		Delay_ms(<span class="number">20</span>);</span><br><span class="line">		<span class="keyword">while</span>(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_2) == <span class="number">0</span>)</span><br><span class="line">		Delay_ms(<span class="number">20</span>);</span><br><span class="line">		<span class="keyword">if</span>(indicator2)&#123;indicator2 = <span class="number">0</span>;kn = <span class="number">3</span>;&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;indicator2 = <span class="number">1</span>;kn = <span class="number">2</span>;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> kn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Logic</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> knum = Key_Num();</span><br><span class="line">	<span class="keyword">if</span>(knum == <span class="number">0</span>)&#123;LED_Control(<span class="number">1</span>,ON);&#125;</span><br><span class="line">	<span class="keyword">if</span>(knum == <span class="number">2</span>)&#123;LED_Control(<span class="number">2</span>,ON);&#125;</span><br><span class="line">	<span class="keyword">if</span>(knum == <span class="number">1</span>)&#123;LED_Control(<span class="number">1</span>,OFF);&#125;</span><br><span class="line">	<span class="keyword">if</span>(knum == <span class="number">3</span>)&#123;LED_Control(<span class="number">2</span>,OFF);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-4-1-Key-Set-GPIO-输入初始化"><a href="#8-4-1-Key-Set-GPIO-输入初始化" class="headerlink" title="8.4.1 Key_Set - GPIO 输入初始化"></a>8.4.1 Key_Set - GPIO 输入初始化</h3><p>LED相关的GPIO的输出初始化已经在前面的章节中有所提及，这里来看GPIO输入的配置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Key_Set</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE); <span class="comment">//enable apb2 clock</span></span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">// structure def &amp; info </span></span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_2; <span class="comment">//pull-up input</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitStructure); <span class="comment">// gpio init</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比起GPIO输出配置，所需要更改的只有初始化信息中的<code>GPIO_InitStructure.GPIO_Mode</code>一项。这里改为字符串<code>GPIO_Mode_IPU</code>,其中<code>IPU</code>表示<code>IN,Push-Pull</code>,也就是上拉输出。由于按键一般都是上拉输出模式，所以在这里这样配置。</p>
<h3 id="8-4-2-Key-Logic-GPIO-读取函数"><a href="#8-4-2-Key-Logic-GPIO-读取函数" class="headerlink" title="8.4.2 Key_Logic - GPIO 读取函数"></a>8.4.2 Key_Logic - GPIO 读取函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GPIO_Init.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ON <span class="string">&quot;ON&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OFF <span class="string">&quot;OFF&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> indicator1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> indicator2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Key_Num</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> kn = <span class="number">9</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(!(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0)))</span><br><span class="line">	&#123;</span><br><span class="line">		Delay_ms(<span class="number">20</span>);</span><br><span class="line">		<span class="keyword">while</span>(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0) == <span class="number">0</span>)</span><br><span class="line">		Delay_ms(<span class="number">20</span>);</span><br><span class="line">		<span class="keyword">if</span>(indicator1)&#123;indicator1 = <span class="number">0</span>;kn = <span class="number">1</span>;&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;indicator1 = <span class="number">1</span>;kn = <span class="number">0</span>;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_2)))</span><br><span class="line">	&#123;</span><br><span class="line">		Delay_ms(<span class="number">20</span>);</span><br><span class="line">		<span class="keyword">while</span>(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_2) == <span class="number">0</span>)</span><br><span class="line">		Delay_ms(<span class="number">20</span>);</span><br><span class="line">		<span class="keyword">if</span>(indicator2)&#123;indicator2 = <span class="number">0</span>;kn = <span class="number">3</span>;&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;indicator2 = <span class="number">1</span>;kn = <span class="number">2</span>;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> kn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Logic</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> knum = Key_Num();</span><br><span class="line">	<span class="keyword">if</span>(knum == <span class="number">0</span>)&#123;LED_Control(<span class="number">1</span>,ON);&#125;</span><br><span class="line">	<span class="keyword">if</span>(knum == <span class="number">2</span>)&#123;LED_Control(<span class="number">2</span>,ON);&#125;</span><br><span class="line">	<span class="keyword">if</span>(knum == <span class="number">1</span>)&#123;LED_Control(<span class="number">1</span>,OFF);&#125;</span><br><span class="line">	<span class="keyword">if</span>(knum == <span class="number">3</span>)&#123;LED_Control(<span class="number">2</span>,OFF);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，函数<code>Key_Num</code>获取并返回按下按键的键码值，这个过程就需要使用 GPIO 输入检测函数来获取键码值。</p>
<p><code>GPIO_ReadInputDataBit</code> 是一个用于读取指定 GPIO 引脚电平状态的函数。在 STM32 标准外设库中，该函数非常常用，用于检测引脚的输入状态（高电平或低电平）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> <span class="title function_">GPIO_ReadInputDataBit</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;`</span><br></pre></td></tr></table></figure>

<ul>
<li><code>GPIOx</code>: 指定要读取的 GPIO 端口。可以是 <code>GPIOA</code> 到 <code>GPIOG</code> 之一。</li>
<li><code>GPIO_Pin</code>: 指定要读取的 GPIO 引脚。可以是 <code>GPIO_Pin_0</code> 到 <code>GPIO_Pin_15</code> 之一。</li>
<li></li>
<li>如果引脚电平为高，返回值为 <code>1</code>。</li>
<li>如果引脚电平为低，返回值为 <code>0</code>。</li>
</ul>
<p>如果需要读取整个 GPIO 端口的状态，就需要使用函数<code>GPIO_ReadInputData</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> <span class="title function_">GPIO_ReadInputData</span><span class="params">(GPIO_TypeDef* GPIOx)</span>;</span><br></pre></td></tr></table></figure>

<p>读取函数除了可以读取输入电平，也可以读取输出电平，只将上面函数的<code>Input</code>改为<code>Output</code>即可得到读取输出电平函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> indicator1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> indicator2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Key_Num</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> kn = <span class="number">9</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(!(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0)))</span><br><span class="line">	&#123;</span><br><span class="line">		Delay_ms(<span class="number">20</span>);</span><br><span class="line">		<span class="keyword">while</span>(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0) == <span class="number">0</span>)</span><br><span class="line">		Delay_ms(<span class="number">20</span>);</span><br><span class="line">		<span class="keyword">if</span>(indicator1)&#123;indicator1 = <span class="number">0</span>;kn = <span class="number">1</span>;&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;indicator1 = <span class="number">1</span>;kn = <span class="number">0</span>;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_2)))</span><br><span class="line">	&#123;</span><br><span class="line">		Delay_ms(<span class="number">20</span>);</span><br><span class="line">		<span class="keyword">while</span>(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_2) == <span class="number">0</span>)</span><br><span class="line">		Delay_ms(<span class="number">20</span>);</span><br><span class="line">		<span class="keyword">if</span>(indicator2)&#123;indicator2 = <span class="number">0</span>;kn = <span class="number">3</span>;&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;indicator2 = <span class="number">1</span>;kn = <span class="number">2</span>;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> kn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量<code>kn</code>为函数<code>Key_Num</code>的中间值，用于承载键码值。初始设为连接的引脚 (0,2) 外任意一个数字，保证没有按下按键时保持上拉到高电平的状态，这里为9.</p>
<p>由于按键按下时低电平，此时读取函数返回 0，所以取反作为 if 语句的判断条件，使用<code>Delay</code>函数消除抖动。while循环在按下时进入死循环，提供松手触发逻辑。松手后再次消除抖动。</p>
<p>由于要实现按一次亮，再按一次灭，使用全局变量<code>indicator</code> 作为亮灭状态的标志（当然这里也可以读取整体输出电平进行取反），亮即为1，反之为0.</p>
<p>亮灭对应的键码值不同，不同键码值对应的逻辑是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Key_Logic</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> knum = Key_Num();</span><br><span class="line">	<span class="keyword">if</span>(knum == <span class="number">0</span>)&#123;LED_Control(<span class="number">1</span>,ON);&#125;</span><br><span class="line">	<span class="keyword">if</span>(knum == <span class="number">2</span>)&#123;LED_Control(<span class="number">2</span>,ON);&#125;</span><br><span class="line">	<span class="keyword">if</span>(knum == <span class="number">1</span>)&#123;LED_Control(<span class="number">1</span>,OFF);&#125;</span><br><span class="line">	<span class="keyword">if</span>(knum == <span class="number">3</span>)&#123;LED_Control(<span class="number">2</span>,OFF);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>LED_Control</code>是控制单个LED亮灭的自定义函数，封装在<code>GPIO_Init</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LED_Control</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> num,<span class="type">const</span> <span class="type">char</span> * state)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(num == <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">		<span class="keyword">if</span>(!(<span class="built_in">strcmp</span>(state,ON)))&#123;GPIO_ResetBits(GPIOA,GPIO_Pin_5);&#125;</span><br><span class="line">		<span class="keyword">else</span> GPIO_SetBits(GPIOA,GPIO_Pin_5);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">2</span>)</span><br><span class="line">  &#123;</span><br><span class="line">		<span class="keyword">if</span>(!(<span class="built_in">strcmp</span>(state,ON)))&#123;GPIO_ResetBits(GPIOA,GPIO_Pin_7);&#125;</span><br><span class="line">		<span class="keyword">else</span> GPIO_SetBits(GPIOA,GPIO_Pin_7);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>入口参数<code>num</code>对应 LED 编号，指针<code>state</code>指向<code>const char</code>类型的字符串。通过<code>strcmp</code>函数比较传入字符串与字符串<code>&quot;ON&quot;</code>就可以执行亮或者灭。</p>
<p>这里使用了预定义，所以填的不是<code>&quot;ON&quot;</code>而是变量名<code>ON</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ON <span class="string">&quot;ON&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OFF <span class="string">&quot;OFF&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>关于字符串传参问题，见这里：[[字符串传参]]</p>
<h1 id="9-外部中断-以对射式红外传感计数为例"><a href="#9-外部中断-以对射式红外传感计数为例" class="headerlink" title="9. 外部中断 - 以对射式红外传感计数为例"></a>9. 外部中断 - 以对射式红外传感计数为例</h1><p>关于中断，见这里：[[中断]]</p>
<p>在STM32微控制器中，<strong>外部中断</strong> 用于响应外部硬件事件（如按钮按下、传感器信号等）。外部中断通过外部中断线<code>EXTI</code>(<strong>External Interrupt</strong>) 实现，允许微控制器在特定引脚上检测外部事件并触发中断。</p>
<p>配置中断：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Sensor_cnt;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sensor_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* ENABLE CLOCK FOR GPIO AND AFIO */</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE); <span class="comment">// enable clock for the whole AFIO</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* the clock for EXTI and NVIC is auto-on because they are connected to the core */</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* GPIO INIT INFO */</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* GPIO INIT*/</span></span><br><span class="line">	GPIO_Init(GPIOB,&amp;GPIO_InitStructure); <span class="comment">//the sensor use only B12 to input data</span></span><br><span class="line">	</span><br><span class="line">  <span class="comment">/* EXTI INIT INFO */</span>	</span><br><span class="line">	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB,GPIO_PinSource12); <span class="comment">//Select GPIOB Pin12 as interrupt source</span></span><br><span class="line">	</span><br><span class="line">	EXTI_InitTypeDef EXTI_InitStructure;</span><br><span class="line">	EXTI_InitStructure.EXTI_Line = EXTI_Line12; <span class="comment">//EXTI line</span></span><br><span class="line">	EXTI_InitStructure.EXTI_LineCmd = ENABLE; <span class="comment">//EXTI line status</span></span><br><span class="line">	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt; <span class="comment">//EXTI mode: Interrupt / Event</span></span><br><span class="line">	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling; <span class="comment">//EXTI trigger: Falling edge (0)</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*EXTI_Init*/</span></span><br><span class="line">	EXTI_Init(&amp;EXTI_InitStructure); <span class="comment">//Only one EXTI exists so pointer to Structure is all it needs</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* NVIC INIT INFO */</span></span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); <span class="comment">//Choose NVIC priority group</span></span><br><span class="line">	</span><br><span class="line">	NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn; <span class="comment">//NVIC channel:EXIT(10-15)</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; <span class="comment">//NVIC mode: Enable</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority =<span class="number">1</span>; <span class="comment">//NVIC PreemptionPriority</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>; <span class="comment">//NVIC SubPriority</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* NVIC INIT */</span></span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Get_cnt</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> Sensor_cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI15_10_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(EXTI_GetITStatus(EXTI_Line12) == SET)</span><br><span class="line">  &#123;</span><br><span class="line">		Sensor_cnt++;</span><br><span class="line">		EXTI_ClearITPendingBit(EXTI_Line12);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-1-配置-GPIO-及-AFIO-中断源选取"><a href="#9-1-配置-GPIO-及-AFIO-中断源选取" class="headerlink" title="9.1 配置 GPIO 及 AFIO - 中断源选取"></a>9.1 配置 GPIO 及 AFIO - 中断源选取</h2><p>GPIO 通常作为通用IO口，如果想要指定 GPIO 某端口引脚作为外部中断源，需要使用 AFIO 进行重映射以及中断选择。</p>
<p>EXTI 有16条中断线，通过 AFIO 将 GPIO 重映射到中断线上，这样 GPIO 才能起到中断源的作用。而由于 GPIO 的每个端口都有 16 个引脚，中断线却只有16条，每个引脚默认占用对应编号的中断线，比如所有 GPIO 端口上的 <code>GPIO_Pin_1</code> 都对应中断线 <code>EXTI_Line1</code>, 所以同编号的引脚不能同时作为中断源。此时需要用 AFIO 进行中断选择，确定 GPIO 中断源的端口以及引脚.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Sensor_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* ENABLE CLOCK FOR GPIO AND AFIO */</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE); <span class="comment">// enable clock for the whole AFIO</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* the clock for EXTI and NVIC is auto-on because they are connected to the core */</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* GPIO INIT INFO */</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* GPIO INIT*/</span></span><br><span class="line">	GPIO_Init(GPIOB,&amp;GPIO_InitStructure); <span class="comment">//the sensor use only B12 to input data</span></span><br><span class="line">	<span class="comment">/* AFIO CONFIG */</span></span><br><span class="line">	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB,GPIO_PinSource12); <span class="comment">//Select GPIOB Pin12 as interrupt source</span></span><br></pre></td></tr></table></figure>

<p>AFIO 和 GPIO 时钟的开启都是用函数<code>RCC_APB2PeriphClockCmd()</code>完成的，在开启 AFIO 时钟时，由于 AFIO 不像 GPIO 那样有多端口，所以第一个参数只需要填<code>RCC_APB2Periph_AFIO</code>。</p>
<p>AFIO的初始化也不需要配置结构体等等，因为在 EXTI 的整个过程中，AFIO 只需要完成中断的选择就可以了，这个操作通过函数<code>GPIO_EXTILineConfig()</code>完成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GPIO_EXTILineConfig</span><span class="params">(<span class="type">uint8_t</span> GPIO_PortSource, <span class="type">uint8_t</span> GPIO_PinSource)</span>;</span><br></pre></td></tr></table></figure>

<p>其中，<code>GPIO_PortSource</code> 是GPIO端口的源，而 <code>GPIO_PinSource</code> 是GPIO引脚的源。常见的端口和引脚定义如下：</p>
<ul>
<li><code>GPIO_PortSourceGPIOA</code>、<code>GPIO_PortSourceGPIOB</code> 等等，用于指定GPIO端口。</li>
<li><code>GPIO_PinSource0</code>、<code>GPIO_PinSource1</code> 等等，用于指定GPIO引脚。</li>
</ul>
<p>像上述代码中的<code>GPIO_EXTILineConfig(GPIO_PortSourceGPIOB,GPIO_PinSource12</code>就指定了GPIOB 的 B12 引脚作为中断源。</p>
<p>虽然函数名字带着 GPIO，实际上着这个过程还是通过 AFIO 的映射完成的。</p>
<h2 id="9-2-配置-EXTI-外部中断信息"><a href="#9-2-配置-EXTI-外部中断信息" class="headerlink" title="9.2 配置 EXTI - 外部中断信息"></a>9.2 配置 EXTI - 外部中断信息</h2><p>GPIO 和 AFIO 配置好中断源之后，就需要对外部中断&#x2F;事件控制器 EXTI 的信息进行配置并初始化 EXTI。</p>
<p>EXTI 属于内核外设，不需要像GPIO 和 AFIO 那样手动开启时钟。EXTI的信息配置与初始化与 GPIO 类似，都是通过结构体来进行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EXTI_InitTypeDef EXTI_InitStructure;</span><br><span class="line">EXTI_InitStructure.EXTI_Line = EXTI_Line12; <span class="comment">//EXTI line</span></span><br><span class="line">EXTI_InitStructure.EXTI_LineCmd = ENABLE; <span class="comment">//EXTI line status</span></span><br><span class="line">EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt; <span class="comment">//EXTI mode: Interrupt / Event</span></span><br><span class="line">EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling; <span class="comment">//EXTI trigger: Falling edge (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*EXTI_Init*/</span></span><br><span class="line">EXTI_Init(&amp;EXTI_InitStructure); <span class="comment">//Only one EXTI exists so pointer to Structure is all it needs</span></span><br></pre></td></tr></table></figure>

<p>EXTI 初始化结构体的四个参数分别是：</p>
<p><code>EXTI_InitStructure.EXTI_Line</code>表示参与中断的中断线，这里选取中断线12，因为在上面AFIO的配置中，已经选定12号引脚为中断源。</p>
<p><code>EXTI_InitStructure.EXTI_LineCmd</code>表示参与中断的中断线的使能状态，值得一提的是函数带有<code>Cmd</code>字样的基本都是使能函数，以<code>ENABLE</code>和<code>DISABLE</code>作为参数。</p>
<p><code>EXTI_InitStructure.EXTI_Mode</code>表示外部中断的模式。外部中断的两种模式分别是<code>EXTI_Mode_Interrupt</code>中断模式以及<code>EXTI_Mode_Event</code>事件模式。这里因为要发生外部中断，配置为中断模式即可。</p>
<p><code>EXTI_InitStructure.EXTI_Trigger</code> 为发生外部中断的条件。外部中断的判断条件可配置为<code>EXTI_Trigger_Rising</code>：在信号上升沿触发；<code>EXTI_Trigger_Falling</code>：在信号下降沿触发；<code>EXTI_Trigger_Rising_Falling</code>：在信号上升沿和下降沿都触发。由于这里的预期功能是遮断红外时发生中断，所以遮断红外时产生下降沿（0），条件选择<code>EXTI_Trigger_Falling</code>。</p>
<h2 id="9-3-配置-NVIC-中断优先级"><a href="#9-3-配置-NVIC-中断优先级" class="headerlink" title="9.3 配置 NVIC - 中断优先级"></a>9.3 配置 NVIC - 中断优先级</h2><p>嵌套向量中断控制器<code>Nested Vector Interrupt Controller</code>, 简称 NVIC，用来配置STM32中中断的优先级。</p>
<p>优先级可分为 <strong>抢占优先级（Preemption Priority）</strong> 和 **响应优先级（Subpriority）。</p>
<p>抢占优先级用于决定哪个中断可以抢占（打断）当前正在执行的中断处理程序。当一个中断处理程序正在执行时，如果另一个具有更高抢占优先级的中断到达，新中断将抢占当前的中断处理程序。 抢占优先级数值越小，优先级越高。</p>
<p>响应优先级用于决定在相同抢占优先级下，哪个中断先响应。如果两个中断具有相同的抢占优先级，但具有不同的响应优先级，则响应优先级较高（数值较低）的中断将先处理。响应优先级数值越小，优先级越高。</p>
<p>STM32的中断优先级配置分为多个组（Group），每个组下对于抢占优先级与优先级配置有所区别。一个优先级可分为四位，配置为n个抢占优先级和 (4-n) 个响应优先级。按 n 的变化可分为下面几组：</p>
<table>
<thead>
<tr>
<th>Group</th>
<th>Preemption Priority</th>
<th>Subpriority</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>4 <em>(0-15)</em></td>
</tr>
<tr>
<td>1</td>
<td>1 <em>(0-1)</em></td>
<td>3 <em>(0-7)</em></td>
</tr>
<tr>
<td>2</td>
<td>2 <em>(0-3)</em></td>
<td>2 <em>(0-3)</em></td>
</tr>
<tr>
<td>3</td>
<td>3 <em>(0-1)</em></td>
<td>1 <em>(0-7)</em></td>
</tr>
<tr>
<td>4</td>
<td>4 <em>(0-15)</em></td>
<td>0</td>
</tr>
</tbody></table>
<p>拥有越多位的优先级，其数值可以取值的范围越大。在表中以斜体标记。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> 	<span class="comment">/* NVIC INIT INFO */</span></span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); <span class="comment">//Choose NVIC priority group</span></span><br><span class="line">	</span><br><span class="line">	NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn; <span class="comment">//NVIC channel:EXIT(10-15)</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; <span class="comment">//NVIC mode: Enable</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority =<span class="number">1</span>; <span class="comment">//NVIC PreemptionPriority</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>; <span class="comment">//NVIC SubPriority</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* NVIC INIT */</span></span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指定优先级分组需要使用函数<code>NVIC_PriorityGroupConfig</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">NVIC_PriorityGroupConfig</span><span class="params">(<span class="type">uint32_t</span> NVIC_PriorityGroup)</span>;</span><br></pre></td></tr></table></figure>

<p>其中 <code>NVIC_PriorityGroup</code> 参数可以是以下值之一，用于配置优先级组：</p>
<ul>
<li><code>NVIC_PriorityGroup_0</code>: 0 bits for preemption priority, 4 bits for subpriority</li>
<li><code>NVIC_PriorityGroup_1</code>: 1 bit for preemption priority, 3 bits for subpriority</li>
<li><code>NVIC_PriorityGroup_2</code>: 2 bits for preemption priority, 2 bits for subpriority</li>
<li><code>NVIC_PriorityGroup_3</code>: 3 bits for preemption priority, 1 bit for subpriority</li>
<li><code>NVIC_PriorityGroup_4</code>: 4 bits for preemption priority, 0 bits for subpriority</li>
</ul>
<p>接下来也是配置初始化结构体的环节。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn; <span class="comment">//NVIC channel:EXIT(10-15)</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; <span class="comment">//NVIC mode: Enable</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority =<span class="number">1</span>; <span class="comment">//NVIC PreemptionPriority</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>; <span class="comment">//NVIC SubPriori</span></span><br></pre></td></tr></table></figure>

<p><code>NVIC_InitStructure.NVIC_IRQChannel</code>指定了优先级所应用的中断通道，比如在这里是外部中断通道 EXTI15-10(外部中断的中断线Line15-10共用一个通道)，则参数为<code>EXTI15_10_IRQn</code>.前半部分位为中断通道的名字<code>EXTI15_10</code>,后半部分<code>IRQn</code>则表示<code>Interrupt Request Number</code>,即中断请求号，简称中断号。</p>
<p><code>NVIC_InitStructure.NVIC_IRQChannelCmd</code>同样地是作为使能开启标志。</p>
<p><code>NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority</code>和<code>NVIC_InitStructure.NVIC_IRQChannelSubPriority</code>参数为抢占优先级和响应优先级分配具体的数值，比如在前面已经分配好了优先级的组为2，那么抢占优先级和响应优先级都占有同样的2位，数值范围都在 (0-3). 由于本例程只需要一个外部中断，所以可以都填1.</p>
<h2 id="9-4-配置-中断处理函数"><a href="#9-4-配置-中断处理函数" class="headerlink" title="9.4 配置 中断处理函数"></a>9.4 配置 中断处理函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EXTI15_10_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(EXTI_GetITStatus(EXTI_Line12) == SET)</span><br><span class="line">	&#123;</span><br><span class="line">		Sensor_cnt++;</span><br><span class="line">		EXTI_ClearITPendingBit(EXTI_Line12);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中断的各项参数都配置好了，接下俩就是配置具体的中断处理函数。当发生外部中断时，主程序立即跳转到中断处理函数并执行。</p>
<p>外部中断线<code>EXTI Line15_10</code>的中断处理函数为<code>void EXTI15_10_IRQHandler(void)</code>。虽然内容可以自定义编辑，但是函数的命名是有限定的，必须命名一致才可以执行。不同类型中断的中断函数名不一样，具体在中断向量表中有明确的规范。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(EXTI_GetITStatus(EXTI_Line12) == SET)</span><br></pre></td></tr></table></figure>

<p>这个 if 语句中调用了函数<code>EXTI_GetITStatus</code>来检查中断线的设置情况，如果发生中断，中断挂起位就会被设置，此时这个函数返回 <code>SET</code>,否则返回<code>RESET</code>.通过 if 语句的调价比对，确认发生了中断，才可以执行具体的处理逻辑。</p>
<p>末了部分调用函数<code>EXTI_ClearITPendingBit</code>来清除中断挂起位，表明中断流程的结束。</p>
<p>这两个函数的入口参数都是外部中断线<code>EXTI_Linex</code>，起到检查以及复位的作用。</p>
<h2 id="9-5-相关函数"><a href="#9-5-相关函数" class="headerlink" title="9.5 相关函数"></a>9.5 相关函数</h2><h2 id="Extra：元件表"><a href="#Extra：元件表" class="headerlink" title="Extra：元件表"></a>Extra：元件表</h2><h1 id="10-定时器中断"><a href="#10-定时器中断" class="headerlink" title="10. 定时器中断"></a>10. 定时器中断</h1><h2 id="10-1-定时器（Timer）"><a href="#10-1-定时器（Timer）" class="headerlink" title="10.1 定时器（Timer）"></a>10.1 定时器（Timer）</h2><p>定时器可以对输入的时钟进行计数，并在计数值达到设定值时触发中断。STM32的定时器拥有16位计数器、预分频器、自动重装寄存器的时基单元，在72MHz计数时钟下可以实现最大59.65s的定时。</p>
<p>$$T_{max} &#x3D; 72*10^{9}&#x2F;65536&#x2F;65536 &#x3D; 59.65s$$</p>
<p>定时器不仅具备基本的定时中断功能，而且还包含内外时钟源选择、输入捕获、输出比较、编码器接口、主从触发模式等多种功能，根据复杂度和应用场景分为了高级定时器、通用定时器、基本定时器三种类型。</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Num</th>
<th>Bus</th>
<th>Feature</th>
</tr>
</thead>
<tbody><tr>
<td>高级定时器</td>
<td>TIM1、TIM8</td>
<td>APB2</td>
<td>拥有通用定时器全部功能，并额外具有重复计数器、死区生成、互补输出、刹车输入等功能</td>
</tr>
<tr>
<td>通用定时器</td>
<td>TIM2、TIM3、TIM4、TIM5</td>
<td>APB1</td>
<td>拥有基本定时器全部功能，并额外具有内外时钟源选择、输入捕获、输出比较、编码器接口、主从触发模式等功能</td>
</tr>
<tr>
<td>基本定时器</td>
<td>TIM6、TIM7</td>
<td>APB1</td>
<td>拥有定时中断、主模式触发DAC的功能</td>
</tr>
</tbody></table>
<h2 id="10-2-定时器中断过程"><a href="#10-2-定时器中断过程" class="headerlink" title="10.2 定时器中断过程"></a>10.2 定时器中断过程</h2><h3 id="10-2-1-时钟源"><a href="#10-2-1-时钟源" class="headerlink" title="10.2.1 时钟源"></a>10.2.1 时钟源</h3><p>定时器时钟的选取有以下几种：</p>
<ul>
<li><p><code>RCC</code>-<code>Reset and Clock Control</code> 内部时钟</p>
</li>
<li><p><code>ETR</code>-<code>External Trigger</code> 外部时钟，比如透过<code>GPIO</code>口提供外部时钟源。</p>
</li>
<li><p><code>ITR</code>-<code>Internal Trigger</code> 其他定时器 - 将另一个定时器的输出作为本定时器的输入<br>$e.g.$<code>TIM1</code>$\rightarrow$<code>TIM2</code>，实现定时器级联，可以延长定时时间。<br>$$T_{Cascade - Max} &#x3D; 59.65*(2^{16})^n\space(s)$$</p>
<p>其中 $n$ 为除去自身以外级联定时器的数目，$2^{16} &#x3D; 65536$.</p>
</li>
<li><p><code>TIX</code>-<code>Timer Input x</code> 输入捕获通道。通常用于输入捕获模式、输出比较模式和 PWM 输入模式等, 可以用来测量外部信号的频率、周期、占空比等参数。</p>
</li>
</ul>
<h3 id="10-2-2-时基单元"><a href="#10-2-2-时基单元" class="headerlink" title="10.2.2 时基单元"></a>10.2.2 时基单元</h3><p><strong>时基单元</strong>在 STM32 微控制器中，主要是指定时器模块中的时间基准配置部分。定时器的时基单元负责生成基本的时间间隔，并为定时器模块的各种功能（如输入捕获、输出比较、PWM、定时中断等）提供基础时钟。</p>
<p>其主要组成部分如下：</p>
<ol>
<li><strong>计数器<code>CNT</code></strong>：一个增量或减量的寄存器，用于记录计数值。</li>
<li><strong>预分频器<code>PSC - Prescaler</code></strong>：用来分频定时器输入时钟频率，以生成计数器的时钟频率。原始频率为$72Mhz$。</li>
<li><strong>自动重装载寄存器<code>ARR - Auto-Reload Register</code></strong>：当计数器的值达到这个寄存器的值时，计数器会被重置，可以用于生成周期性事件。</li>
</ol>
<h3 id="10-2-3-中断输出控制与-NVIC"><a href="#10-2-3-中断输出控制与-NVIC" class="headerlink" title="10.2.3 中断输出控制与 NVIC"></a>10.2.3 中断输出控制与 NVIC</h3><p>由于定时器中断内部还有其他很多中断（比如输入捕获等等），所以需要由中断输入控制来控制多个中断，为需要的中断置允许位，不需要的中断则不予执行。</p>
<p>NVIC 在上个章节已经提到过，用于控制中断优先级。</p>
<h2 id="10-3-定时器中断-RCC-内部时钟"><a href="#10-3-定时器中断-RCC-内部时钟" class="headerlink" title="10.3 定时器中断 - RCC 内部时钟"></a>10.3 定时器中断 - RCC 内部时钟</h2><h1 id="11-TIM-输出比较"><a href="#11-TIM-输出比较" class="headerlink" title="11. TIM 输出比较"></a>11. TIM 输出比较</h1><h2 id="11-1-PWM"><a href="#11-1-PWM" class="headerlink" title="11.1 PWM"></a>11.1 PWM</h2><p>PWM（Pulse Width Modulation，脉宽调制）是一种通过改变脉冲宽度来控制模拟信号的方法。PWM的主要应用包括控制电机速度、调节LED亮度、产生音频信号等。</p>
<h3 id="11-1-1-工作原理"><a href="#11-1-1-工作原理" class="headerlink" title="11.1.1 工作原理"></a>11.1.1 工作原理</h3><p>PWM信号是由周期性重复的脉冲组成的。通过调整每个周期内脉冲的“高”时间（即脉冲宽度），可以控制信号的平均功率。关键参数包括：</p>
<ol>
<li><strong>周期（Period）</strong>：PWM信号重复的时间周期，通常以秒（s）或毫秒（ms）为单位。</li>
<li><strong>占空比（Duty Cycle）</strong>：高电平时间占整个周期的比例，通常以百分比表示。占空比越高，平均输出电压越高。</li>
</ol>
<h3 id="11-1-2-应用示例"><a href="#11-1-2-应用示例" class="headerlink" title="11.1.2 应用示例"></a>11.1.2 应用示例</h3><ol>
<li><p><strong>控制电机速度</strong>：</p>
<ul>
<li>使用PWM信号控制电机驱动器。通过改变占空比，可以调节电机的速度。例如，占空比越高，电机转速越快。</li>
</ul>
</li>
<li><p><strong>调节LED亮度</strong>：</p>
<ul>
<li>使用PWM信号控制LED亮度。通过改变占空比，可以调节LED的亮度。例如，占空比越高，LED越亮。</li>
</ul>
</li>
<li><p><strong>产生音频信号</strong>：</p>
<ul>
<li>使用PWM信号可以生成不同频率的音频信号，通过调整PWM周期和占空比来产生不同的音调。</li>
</ul>
</li>
</ol>
<h2 id="11-2-OC（Output-Compare）输出比较"><a href="#11-2-OC（Output-Compare）输出比较" class="headerlink" title="11.2 OC（Output Compare）输出比较"></a>11.2 OC（Output Compare）输出比较</h2><p>定时器可透过输出比较功能，通过比较时基单元中的计数器<code>CNT</code>与 比较&#x2F;捕获 寄存器<code>CCR</code>的值来输出不同高低的电平，并以此来输出 PWM 信号。</p>
<p>单个 高级&#x2F;通用 定时器一共有四个比较捕获单元和四条 比较&#x2F;捕获 通道，即<code>CH1-CH4</code>,每一路通道的输出都与特定的 GPIO 连接，作为 GPIO 复用的一项功能。这个特定的 GPIO 无法更改，是唯一确定的。</p>
<h2 id="11-3-使用定时器输出PWM波-呼吸灯"><a href="#11-3-使用定时器输出PWM波-呼吸灯" class="headerlink" title="11.3 使用定时器输出PWM波 - 呼吸灯"></a>11.3 使用定时器输出PWM波 - 呼吸灯</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PWM_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*ENABLE CLOCK*/</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*GPIO INIT*/</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure; </span><br><span class="line">	</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; </span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; </span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitStructure); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*TIM CHOOSE CLOCK SOURCE - INTERNAL CLOCK*/</span></span><br><span class="line">	TIM_InternalClockConfig(TIM2);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*TIMEBASE INIT*/</span></span><br><span class="line">	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Period = <span class="number">100</span><span class="number">-1</span>;</span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">720</span><span class="number">-1</span>;</span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">	TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*OUTPUT COMPARE INIT - GENERATE PWM*/</span></span><br><span class="line">	TIM_OCInitTypeDef TIM_OCInitStructure;</span><br><span class="line">	TIM_OCStructInit(&amp;TIM_OCInitStructure);</span><br><span class="line">	</span><br><span class="line">	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;</span><br><span class="line">	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;</span><br><span class="line">	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;</span><br><span class="line">	TIM_OCInitStructure.TIM_Pulse = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	TIM_OC1Init(TIM2,&amp;TIM_OCInitStructure);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*UPDATE ENABLE*</span></span><br><span class="line"><span class="comment">	TIM_ClearFlag(TIM2,TIM_FLAG_Update);</span></span><br><span class="line"><span class="comment">	TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	/*NVIC INIT*/</span></span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">	NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*TIM ENABLE*/</span></span><br><span class="line">	TIM_Cmd(TIM2,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWM_Logic</span><span class="params">(<span class="type">int</span> compare)</span></span><br><span class="line">&#123;</span><br><span class="line">	TIM_SetCompare1(TIM2,compare);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="11-3-1-GPIO-配置"><a href="#11-3-1-GPIO-配置" class="headerlink" title="11.3.1 GPIO 配置"></a>11.3.1 GPIO 配置</h3><p>产生PWM波不需要定时中断，也不需要使用外部时钟，但是需要透过GPIO口进行输出。定时器的 捕获&#x2F;比较 通道一共有四路，各自对应唯一的 GPIO 端口。</p>
<p>配置和普通 GPIO 的初始化设置是一样的，只不过模式需要配置为<code>GPIO_Mode_AF_PP</code>,复用推挽输出，因为PA0口需要复用为比较&#x2F;捕获输出口。</p>
<table>
<thead>
<tr>
<th>Channel</th>
<th>GPIO</th>
</tr>
</thead>
<tbody><tr>
<td><code>Ch1</code></td>
<td><code>PA0</code></td>
</tr>
<tr>
<td><code>Ch2</code></td>
<td><code>PA1</code></td>
</tr>
<tr>
<td><code>Ch3</code></td>
<td><code>PA2</code></td>
</tr>
<tr>
<td><code>Ch4</code></td>
<td><code>PA3</code></td>
</tr>
</tbody></table>
<h3 id="11-3-2-TIM-配置"><a href="#11-3-2-TIM-配置" class="headerlink" title="11.3.2 TIM 配置"></a>11.3.2 TIM 配置</h3><p>时基部分与上面相同。根据需要与元件要求可以更改<code>PSC</code>与<code>ARR</code>来改变输出PWM</p>
<p>定时器的启动配置同上，但由于不需要中断的参与，就无需配置 NVIC 以及清除标志位了，以下是需要注释掉的部分：</p>
<p>在配置完OC之后，记得使能定时器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/*UPDATE ENABLE*</span></span><br><span class="line"><span class="comment">TIM_ClearFlag(TIM2,TIM_FLAG_Update);</span></span><br><span class="line"><span class="comment">TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">/*NVIC INIT*</span></span><br><span class="line"><span class="comment">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span></span><br><span class="line"><span class="comment">NVIC_InitTypeDef NVIC_InitStructure;</span></span><br><span class="line"><span class="comment">NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;</span></span><br><span class="line"><span class="comment">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span></span><br><span class="line"><span class="comment">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;</span></span><br><span class="line"><span class="comment">NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">NVIC_Init(&amp;NVIC_InitStructure);</span></span><br></pre></td></tr></table></figure>

<h3 id="11-3-3-OC-配置"><a href="#11-3-3-OC-配置" class="headerlink" title="11.3.3 OC 配置"></a>11.3.3 OC 配置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*OUTPUT COMPARE INIT - GENERATE PWM*/</span></span><br><span class="line">	TIM_OCInitTypeDef TIM_OCInitStructure;</span><br><span class="line">	TIM_OCStructInit(&amp;TIM_OCInitStructure);</span><br><span class="line">	</span><br><span class="line">	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;</span><br><span class="line">	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;</span><br><span class="line">	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;</span><br><span class="line">	TIM_OCInitStructure.TIM_Pulse = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	TIM_OC1Init(TIM2,&amp;TIM_OCInitStructure);</span><br></pre></td></tr></table></figure>

<p>在选用通用定时器时，高级定时器的部分功能使用不到，但是也必须对结构体中的高级定时器占用的配置进行赋值，否则可能会出现工作异常，此时就可以用到函数<code>TIM_OCStructInit</code>来为结构体成员赋初值，然后再手动配置通用定时器的配置，如下。</p>
<p>通用定时器结构体的成员有四个，分别是：</p>
<ul>
<li><p><code>TIM_OCInitStructure.TIM_OCMode</code>,OC模式选择，在此处配置为<code>TIM_OCMode_PWM1</code>,即使用 <code>PWM1</code> 模式输出。</p>
</li>
<li><p><code>TIM_OCInitStructure.TIM_OCPolarity</code>，极性选择，在此处配置为<code>TIM_OCPolarity_High</code>,则按照变化情况输出电平,不对输出电平取反.</p>
</li>
<li><p><code>TIM_OCInitStructure.TIM_OutputState</code>，输出使能，配置为<code>TIM_OutputState_Enable</code>即使能输出。</p>
</li>
<li><p><code>TIM_Pulse</code>，<code>CCR</code>值，通过改变<code>CCR</code>值以改变输出 PWM 的占空比。这里默认配置为0，这之后可以再进一步用其他函数修改。</p>
</li>
</ul>
<h3 id="11-3-4-设置-PWM-参数"><a href="#11-3-4-设置-PWM-参数" class="headerlink" title="11.3.4 设置 PWM 参数"></a>11.3.4 设置 PWM 参数</h3><p>PWM 信号频率计算公式：</p>
<p>$$Freqency &#x3D; \frac{ClockPSC}{(PSC+1)(ARR+1)}\space,\space ClockPSC &#x3D; 72MHz &#x3D; 7.2*10^7Hz$$</p>
<p>PWM 占空比计算公式：<br>$$Duty\space Ratio &#x3D; \frac{CCR}{(ARR+1)}$$</p>
<p>PWM 分辨率公式：<br>$$Resolution &#x3D; \frac{1}{(ARR+1)}$$</p>
<p>假设此时需要设置频率为 <code>1KHz</code>的 PWM 信号来驱动 LED 成为呼吸灯效果，那么可以令频率计算式中的<code>(PSC+1) = 720,PSC = 719</code>以及<code>(ARR+1) = 100,ARR = 99</code>,就可以计算得到：</p>
<p>$$Freqency &#x3D; \frac{7.2<em>10^7}{7.2</em>10^4} &#x3D; 1000(Hz)$$<br>将<code>ARR</code>与<code>PSC</code>在时基部分设置就可以了。</p>
<p>接下来是动态改变<code>CCR</code>的值以实时调节占空比。这里需要用到函数<code>TIM_SetCompare1</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PWM_Logic</span><span class="params">(<span class="type">int</span> compare)</span></span><br><span class="line">&#123;</span><br><span class="line">	TIM_SetCompare1(TIM2,compare);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义函数<code>PWM_Logic</code>的参数<code>compare</code>即实时的<code>CCR</code>值，透过<code>TIM_SetCompare1</code>对<code>CCR</code>进行设置。（因为结构体成员中的<code>TIM_Pulse</code>只能赋初值，更改就不方便了）。</p>
<p>在主函数中使用可以这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	OLED_Init();</span><br><span class="line">	PWM_Init();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">	    &#123;</span><br><span class="line">			PWM_Logic(i);</span><br><span class="line">			Delay_ms(<span class="number">10</span>);</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">	    &#123;</span><br><span class="line">			PWM_Logic(<span class="number">100</span>-i);</span><br><span class="line">			Delay_ms(<span class="number">10</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以让占空比实时变化，达到呼吸灯的效果（亮度的均匀变化）。</p>
<h2 id="11-4-驱动舵机"><a href="#11-4-驱动舵机" class="headerlink" title="11.4 驱动舵机"></a>11.4 驱动舵机</h2><p>舵机（Servo Motor）是一种通过精确控制角度位置来实现精准运动的电机装置，广泛应用于机器人、遥控飞机、无人机、汽车、自动化设备等领域。舵机通常由电机、齿轮、位置传感器和控制电路组成。</p>
<p>舵机的组成部分一般如下：</p>
<ol>
<li><strong>电机</strong>：提供旋转运动，一般是直流电机或无刷电机。</li>
<li><strong>齿轮组</strong>：用于降低电机的转速和增加扭矩。</li>
<li><strong>位置传感器</strong>：通常是一个电位计，用于反馈当前的位置。</li>
<li><strong>控制电路</strong>：接收控制信号并将其转换为相应的电机运动。</li>
</ol>
<h3 id="11-4-1-舵机行为"><a href="#11-4-1-舵机行为" class="headerlink" title="11.4.1 舵机行为"></a>11.4.1 舵机行为</h3><p>输入PWM信号要求：周期为20ms，高电平宽度为0.5ms~2.5ms，也就是舵机的工作条件：</p>
<ul>
<li>频率为 50 Hz</li>
<li>占空比范围 $\in[0.025,0.125]$</li>
</ul>
<p>舵机根据占空比的不同，其转动的角度也不同。</p>
<table>
<thead>
<tr>
<th>$T_{on}&#x2F;ms$</th>
<th>$Duty\space Ratio$</th>
<th>$Angle°（平行舵机方向取0°）$</th>
<th>$Angle°（垂直舵机方向取0°）$</th>
</tr>
</thead>
<tbody><tr>
<td>0.5</td>
<td>0.025</td>
<td>-90°</td>
<td>0°</td>
</tr>
<tr>
<td>1</td>
<td>0.05</td>
<td>-45°</td>
<td>45°</td>
</tr>
<tr>
<td>1.5</td>
<td>0.075</td>
<td>0°</td>
<td>90°</td>
</tr>
<tr>
<td>2</td>
<td>0.1</td>
<td>45°</td>
<td>135°</td>
</tr>
<tr>
<td>2.5</td>
<td>0.125</td>
<td>90°</td>
<td>180°</td>
</tr>
</tbody></table>
<p>影响频率的因素为<code>PSC</code>与<code>ARR</code>,影响占空比因素的为<code>ARR</code>与<code>CCR</code>,在根据所需要的频率配置好<code>PSC</code>与<code>ARR</code>后就可以对<code>CCR</code>进行配置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TIM_TimeBaseInitStructure.TIM_Period = <span class="number">2000</span><span class="number">-1</span>;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">720</span><span class="number">-1</span>;</span><br></pre></td></tr></table></figure>

<p>根据上表，对应的<code>CCR</code>值应为</p>
<table>
<thead>
<tr>
<th><code>CCR</code></th>
<th>$Angle°（平行舵机方向取0°）$</th>
<th>$Angle°（垂直舵机方向取0°）$</th>
</tr>
</thead>
<tbody><tr>
<td>50</td>
<td>-90°</td>
<td>0°</td>
</tr>
<tr>
<td>100</td>
<td>-45°</td>
<td>45°</td>
</tr>
<tr>
<td>150</td>
<td>0°</td>
<td>90°</td>
</tr>
<tr>
<td>200</td>
<td>45°</td>
<td>135°</td>
</tr>
<tr>
<td>250</td>
<td>90°</td>
<td>180°</td>
</tr>
</tbody></table>
<p>取角度值的数值，可以得到以下映射关系（平行舵机方向取0°）：</p>
<p>$$CCR &#x3D; \frac{Angle}{45}*50+150$$<br>垂直舵机方向取0°：</p>
<p>$$CCR &#x3D; [\frac{Angle}{45}+1]*50$$</p>
<h3 id="11-4-2-档位调节"><a href="#11-4-2-档位调节" class="headerlink" title="11.4.2 档位调节"></a>11.4.2 档位调节</h3><p>取垂直舵机角度为0°的情形。</p>
<p>预期功能使用按钮来进行档位条件，幅度为15°，并且角度的范围在0-180°内。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PWM_Logic</span><span class="params">(<span class="type">int</span> angle)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> pulse_width = (<span class="type">int</span>)(((angle / <span class="number">45.0</span>) + <span class="number">1.0</span>) * <span class="number">50.0</span>);</span><br><span class="line">	TIM_SetCompare2(TIM2,pulse_width);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CCR</code>的值只能为整数，但是运算式中包括除法，如果以<code>int angle</code>输出会遇到小数截断的问题，而且在这种情况保留精度的情况并不理想。在这种情况下，<code>angle</code>每增大45°才能使得除法的结果发生变化，最终舵机的转动角就不能实时根据转动幅度变化了。</p>
<p>如果以<code>float angle</code>输入原式，那么就不满足<code>CCR</code>的类型要求，导致舵机根本不工作。</p>
<p>在这里，将式子中的所有数据改为浮点数，这样用<code>int angle</code>计算时就可以保留精度。再用强制类型转换将保留了精度的数据转成<code>int</code>类型，就可以使得输入的<code>CCR</code>既为整数，又能保留多两位左右的有效数字，即使转动幅度＜45°时，也能精确地得出<code>CCR</code>，舵机能实时转动。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PWM.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> knum;</span><br><span class="line"><span class="type">int</span> angle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	OLED_Init();</span><br><span class="line">	PWM_Init();</span><br><span class="line">	Key_Init();</span><br><span class="line">	OLED_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;Angle:&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">		knum = Key_Num();</span><br><span class="line">		<span class="keyword">if</span>(knum == <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			angle += <span class="number">15</span>;</span><br><span class="line">			<span class="keyword">if</span>(angle &gt; <span class="number">180</span>)&#123;angle = <span class="number">0</span>;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		PWM_Logic(angle);</span><br><span class="line">		OLED_ShowNum(<span class="number">1</span>,<span class="number">7</span>,angle,<span class="number">3</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数当中，使用简单的按键判断逻辑来完成<code>angle</code>的改变。封装的按键函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*GPIO INIT*/</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure; </span><br><span class="line">	</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; </span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11; </span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	</span><br><span class="line">	GPIO_Init(GPIOB,&amp;GPIO_InitStructure); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Key_Num</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> kn = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Delay_ms(<span class="number">20</span>);</span><br><span class="line">		<span class="keyword">while</span>(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11) == <span class="number">0</span>)</span><br><span class="line">		Delay_ms(<span class="number">20</span>);</span><br><span class="line">		kn = <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> kn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-5-透过-TB6612-驱动直流电机"><a href="#11-5-透过-TB6612-驱动直流电机" class="headerlink" title="11.5 透过 TB6612 驱动直流电机"></a>11.5 透过 TB6612 驱动直流电机</h2><h1 id="12-TIM-输入捕获"><a href="#12-TIM-输入捕获" class="headerlink" title="12. TIM 输入捕获"></a>12. TIM 输入捕获</h1><h2 id="12-1-IC-模式：测量-PWM-的频率"><a href="#12-1-IC-模式：测量-PWM-的频率" class="headerlink" title="12.1 IC 模式：测量 PWM 的频率"></a>12.1 IC 模式：测量 PWM 的频率</h2><h2 id="12-2-PWMI-模式：测量-PWM-信号的频率与占空比"><a href="#12-2-PWMI-模式：测量-PWM-信号的频率与占空比" class="headerlink" title="12.2 PWMI 模式：测量 PWM 信号的频率与占空比"></a>12.2 PWMI 模式：测量 PWM 信号的频率与占空比</h2><h2 id="12-3-TIM-编码器接口"><a href="#12-3-TIM-编码器接口" class="headerlink" title="12.3 TIM  编码器接口"></a>12.3 TIM  编码器接口</h2><h3 id="12-3-1-编码器接口（Encoder-Interface）"><a href="#12-3-1-编码器接口（Encoder-Interface）" class="headerlink" title="12.3.1 编码器接口（Encoder Interface）"></a>12.3.1 编码器接口（Encoder Interface）</h3><p>编码器接口可接收增量（正交）编码器的信号，根据编码器旋转产生的正交信号脉冲，自动控制<code>CNT</code>自增或自减，从而指示编码器的位置、旋转方向和旋转速度。</p>
<p>每个高级定时器和通用定时器都拥有1个编码器接口，两个输入引脚借用了输入捕获的通道1和通道2，也就是说<code>CH3</code>与<code>CH4</code>是不可以使用编码器接口的。一个定时器使用了编码器接口课后，其功能基本上也就限定在编码器记次了，资源比较紧张。</p>
<h3 id="12-3-2-正交编码器"><a href="#12-3-2-正交编码器" class="headerlink" title="12.3.2 正交编码器"></a>12.3.2 正交编码器</h3><p>正交编码器（Quadrature Encoder）是一种常用于测量旋转角度、速度和方向的传感器。它广泛应用于工业自动化、机器人、数控机床和其他需要精确位置反馈的系统中。正交编码器通过产生两个相位相差90度的正交信号来实现位置和速度测量。</p>
<p>正交编码器通常由一个旋转盘和两个光电传感器组成。旋转盘上有等间距的光学编码条或磁条。当盘旋转时，光电传感器检测到这些条的变化并生成两个相位相差90度的正交信号（通常称为A和B信号）。通过分析A和B信号的相位关系，可以确定旋转方向和旋转量。</p>
<p>假设一个正交编码器连接到一个旋转轴上，当轴旋转时，编码器产生两个正交信号A和B：</p>
<ul>
<li>如果A信号领先于B信号，表示旋转方向为顺时针。</li>
<li>如果B信号领先于A信号，表示旋转方向为逆时针。</li>
</ul>
<p>观察A,B两相的波形图，还可以发现以下的对应关系：</p>
<p>（1）当A相落后B相时（假定正转）</p>
<table>
<thead>
<tr>
<th>边沿</th>
<th>另一相状态</th>
</tr>
</thead>
<tbody><tr>
<td>A相↑</td>
<td>B相低电平</td>
</tr>
<tr>
<td>A相↓</td>
<td>B相高电平</td>
</tr>
<tr>
<td>B相↑</td>
<td>A相高电平</td>
</tr>
<tr>
<td>B相↓</td>
<td>A相低电平</td>
</tr>
</tbody></table>
<p>（2）当A相超前B相时（反转）</p>
<table>
<thead>
<tr>
<th>边沿</th>
<th>另一相状态</th>
</tr>
</thead>
<tbody><tr>
<td>A相↑</td>
<td>B相高电平</td>
</tr>
<tr>
<td>A相↓</td>
<td>B相低电平</td>
</tr>
<tr>
<td>B相↑</td>
<td>A相低电平</td>
</tr>
<tr>
<td>B相↓</td>
<td>A相高电平</td>
</tr>
</tbody></table>
<p>每当A和B信号的状态发生变化时，系统计数器<code>CNT</code>就会增减，从而实现精确的角度和位置测量。正交信号由于是两路记次，记次的频率高，精度高，而且抗噪声的效果也比较好。</p>
<h3 id="12-3-3-为什么使用编码器接口-编码器测速原理"><a href="#12-3-3-为什么使用编码器接口-编码器测速原理" class="headerlink" title="12.3.3 为什么使用编码器接口 &#x2F; 编码器测速原理"></a>12.3.3 为什么使用编码器接口 &#x2F; 编码器测速原理</h3><p>使用定时器进行编码器记次，有利于节省软件资源。配置好定时器编码器接口后，编码器的记次由硬件全自动记次，如果使用外部中断进行编码器记次的话，在电机高速旋转的时候，编码器会产生高频脉冲，导致高频中断，且终端的内容很简单（就是对记次进行加减），会浪费大量的软件资源，用定时器编码器接口记次就可以解决这个问题。</p>
<p>对于这种频繁执行，操作简单的需求，一般都是通过设计专门的硬件电路模块来自动完成。</p>
<p>编码器接口就是这样的一种用来记次的电路。不断进行记次的同时，每隔一段时间读取记次值就可以得到编码器的旋转速度。这个速度是带方向的。</p>
<p>通过单相输出信号的波形频率，可以计算出编码器（电机）的速率，而旋转方向则需根据此相与另一相信号的相位关系来进行判断。</p>
<p>具体的方法与用测频法测正交脉冲的频率是一样的（所以在IC内容中）。</p>
<h3 id="12-3-4-实际应用"><a href="#12-3-4-实际应用" class="headerlink" title="12.3.4 实际应用"></a>12.3.4 实际应用</h3><p>在实际应用中，通常采用这种方法测量电机的速度。使用 PWM 驱动电机之后，用编码器测量电机的速度，最后使用 PID 算法进行闭环控制。</p>
<p>电机转速较高的情景一般使用 光栅&#x2F;霍尔传感器型编码器。</p>
<h3 id="12-3-5-编码器接口的工作原理"><a href="#12-3-5-编码器接口的工作原理" class="headerlink" title="12.3.5 编码器接口的工作原理"></a>12.3.5 编码器接口的工作原理</h3><p>根据在 12.3.2 中总结出的关系，可以将A或者B相的所有边沿作为计数时钟，当出现边沿信号时<code>CNT</code>就发生改变，改变是增是减则根据产生边沿信号时另一相信号的电平来确定。</p>
<p>编码器接口的A相、B相输入分别连接到<code>CH1</code>和<code>CH2</code>的<code>TI1FP1</code>和<code>TI2FP2</code>,所以<code>CH1</code>和<code>CH2</code>对应的引脚就是编码器接口的输入引脚，对应GPIO口也就是<code>PA6</code>和<code>PA7</code>。 </p>
<p>也就是说，编码器接口需要使用输入捕获中的输入滤波器和边缘检测器，而后续部分的与分频器<code>PSC</code>和比较捕获寄存器<code>CCR</code>、以及触发信号源的连接模式无关，不需要进行配置。</p>
<p>编码器接口的输出连接到<code>CNT</code>,此时其在时基单元中经<code>PSC</code>预分频后的时钟频率<code>CK_PSC</code>以及计时模式<code>Counter_Mode</code>都无效，因为这两个功能的参数都被编码器接口所托管。</p>
<p>当然，此处的自动重装寄存器<code>ARR</code>值是有效的，一般设置为最大量程<code>65535</code>，这样做的好处当计数为负时，是从<code>65535</code>开始减起，而<code>65535</code>根据补码的相关定义等同于<code>-1</code>,就可以直接得到负数</p>
<h3 id="12-3-6-编码器接口的工作模式"><a href="#12-3-6-编码器接口的工作模式" class="headerlink" title="12.3.6 编码器接口的工作模式"></a>12.3.6 编码器接口的工作模式</h3><p>编码器接口可以选择仅A相或B相作为有效边沿，而忽略另一相的情况。在 12.2.3 的表中就表示为只有其中两项有效。编码器接口也可以选择两个相都作为有效边沿，这也是一般情况下使用的模式，因为其精度最高。</p>
<h3 id="12-3-7-Code-测量编码器速度"><a href="#12-3-7-Code-测量编码器速度" class="headerlink" title="12.3.7 Code: 测量编码器速度"></a>12.3.7 Code: 测量编码器速度</h3><p>编码器接口会使用定时器的<code>CH1</code>和<code>CH2</code>两条通道，这里选择<code>TIM3</code>作为编码器接口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Encoder_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3,ENABLE);</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br></pre></td></tr></table></figure>

<p>开启<code>GPIO</code>与定时器时钟，<code>PA6</code>与<code>PA7</code>作为<code>TIM3</code>的IC引脚，采用上拉输入模式。编码器的两个相位输出就是接在这里。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*TIM CHOOSE CLOCK SOURCE - INTERNAL CLOCK*/</span></span><br><span class="line"><span class="comment">//TIM_InternalClockConfig(TIM3); --&gt; EncoderInterface</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*TIMEBASE INIT*/</span></span><br><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; <span class="comment">//---&gt; Encoder Interface</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Period = <span class="number">65536</span><span class="number">-1</span>; <span class="comment">//Full</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">1</span><span class="number">-1</span>; <span class="comment">//0 ----&gt; Encoder Interface</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">TIM_TimeBaseInit(TIM3,&amp;TIM_TimeBaseInitStructure);</span><br></pre></td></tr></table></figure>

<p>这里定时器的内部时钟由<code>TIM_CKD_DTV</code>参数知不分频，但是由于在编码器接口的模式下，内部时钟是交由编码器接口托管的，所以这里并不需要选择时钟源。将时钟源选择函数<code>TIM_InternalClockConfig(TIM3)</code>注释掉正是因为如此。</p>
<p>随后配制时基单元，参数中的计数模式<code>CounterMode</code>和预分频<code>PSC</code>也无关紧要，都会被编码器接口托管。而<code>TIM_Period</code>即周期或自动重装值<code>ARR</code>设置为最大，这样可以防止计数溢出，同时设置为<code>65535</code>的另一个好处在12.3.5已经提到。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TIM_ICInitTypeDef TIM_ICInitStructure;</span><br><span class="line">TIM_ICStructInit(&amp;TIM_ICInitStructure); <span class="comment">//PSC and Selection is not used </span></span><br><span class="line">                                        <span class="comment">//Pre-config to maintain the integrality</span></span><br><span class="line">TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;</span><br><span class="line">TIM_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>; <span class="comment">//Filter used</span></span><br><span class="line"><span class="comment">//TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising; //Polarity used in Output </span></span><br><span class="line">																														  <span class="comment">//(edge detect ---&gt; Encoder Interface)</span></span><br><span class="line"><span class="comment">//TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;</span></span><br><span class="line"><span class="comment">//TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;</span></span><br><span class="line">TIM_ICInit(TIM3,&amp;TIM_ICInitStructure);</span><br><span class="line"></span><br><span class="line">TIM_ICInitStructure.TIM_Channel = TIM_Channel_2;</span><br><span class="line">TIM_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>; </span><br><span class="line">TIM_ICInit(TIM3,&amp;TIM_ICInitStructure);</span><br></pre></td></tr></table></figure>

<p>由于<code>CH1</code>和<code>CH2</code>都会用到来捕获两相信号，所以两路的IC配置都必须开启。两路IC配置中的极性<code>TIM_ICPolarity</code>在下面会有函数单独进行设置，所以在IC启动配置中就不需要配置了。而IC预分频<code>TIM_ICPrescaler</code>和连接模式<code>TIM_ICSelection</code>也都不需要用到。</p>
<p>总体来看，编码器接口模式下IC配置只有通道选择和滤波器模式<code>TIM_ICFilter</code>需要配置，这里配置为最大<code>0xF</code>防止毛刺噪声。由于只配置了这一项，所以在声明完启动结构体之后需要用函数<code>TIM_ICStructInit(&amp;TIM_ICInitStructure)</code>为结构体所有成员赋初值。这个函数只需要调用一次。<code>CH1</code>配置并启动后直接修改通道和滤波器启动<code>CH2</code>就可以了，因为本质上用的是同一个最先已经声明的结构体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TIM_SelectInputTrigger(TIM3,TIM_TS_TI1FP1);</span></span><br><span class="line"><span class="comment">//TIM_SelectSlaveMode(TIM3,TIM_SlaveMode_Reset);</span></span><br><span class="line"></span><br><span class="line">TIM_EncoderInterfaceConfig</span><br><span class="line">(TIM3,TIM_EncoderMode_TI12,TIM_ICPolarity_Rising,TIM_ICPolarity_Rising);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*TIM ENABLE*/</span></span><br><span class="line">TIM_Cmd(TIM3,ENABLE);</span><br></pre></td></tr></table></figure>

<p>主从模式的选择也是不会用到的，直接注释掉。下面需要调用函数<code>TIM_EncoderInterfaceConfig</code>,这个函数是专门用来配置编码器接口设置的。第二个参数选择<code>TIM_EncoderMode_TI12</code>表示<code>CH1</code>和<code>CH2</code>捕获的边沿都是有效边沿。后两个参数相当于IC配置中的极性。</p>
<p>值得注意的是这里的极性代表是否对输出的电平取反，而不是选择上升沿或者下降沿，因为编码器接口模式下上升沿和下降沿都是有效对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int16_t</span> <span class="title function_">Get_Encoder</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">short</span> <span class="type">int</span> cnt_temp = TIM_GetCounter(TIM3);</span><br><span class="line">	TIM_SetCounter(TIM3,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> cnt_temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来获取速度。获取速度的逻辑是设置闸门时间，并获取这段时间内从0开始计数的<code>cnt</code>值，就可以用于表示速度。在这里的代码逻辑就是获取完一次<code>cnt</code>后立马将<code>cnt</code>清零，作为下次闸门时间的计数开始值。获取到的值用暂时变量<code>short int cnt_temp</code>存储并返回。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Encoder.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Timer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">short</span> <span class="type">int</span> speed;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	OLED_Init();</span><br><span class="line">	OLED_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;SPEED:&quot;</span>);</span><br><span class="line">	Timer_Init();</span><br><span class="line">	Encoder_Init();	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">		OLED_ShowSignedNum(<span class="number">1</span>,<span class="number">7</span>,speed,<span class="number">5</span>);</span><br><span class="line">		<span class="comment">//Delay_ms(1000);</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM2_IRQHandler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(TIM_GetITStatus(TIM2,TIM_IT_Update) == SET)</span><br><span class="line">	&#123;</span><br><span class="line">		speed = Get_Encoder();</span><br><span class="line">		TIM_ClearITPendingBit(TIM2,TIM_IT_Update);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>闸门时间的设置可以通过定时器或者延时函数完成。在这里，预期将闸门时间设置为<code>1s</code>，那么速度的意义就是<code>1s</code>内通过的脉冲数。在一定程度上反映了电机（假设编码器与之相连）转动的快慢程度。</p>
<p>由于用函数延时<code>1s</code>在具有复杂任务的程序中会占用资源，这里就用定时器执行周期<code>1s</code>的定时中断，定时中断就是获取<code>Get_Encoder()</code>的值为<code>Speed</code>。</p>
<p>主函数中循环调用Oled显示函数显示<code>Speed</code>，<code>speed</code>每隔<code>1s</code>变化一次，就可以反映速度。</p>
<hr>
<p>调试日志</p>
<ol>
<li>旋转编码器，OLED显示速度变成<code>1</code>后立马跳变回<code>0</code><br>解决方案：将STM32的引脚插得更深一点</li>
</ol>
<h1 id="13-ADC-模数转换"><a href="#13-ADC-模数转换" class="headerlink" title="13. ADC 模数转换"></a>13. ADC 模数转换</h1><h2 id="13-1-ADC-模拟-数字转换器"><a href="#13-1-ADC-模拟-数字转换器" class="headerlink" title="13.1 ADC 模拟 - 数字转换器"></a>13.1 ADC 模拟 - 数字转换器</h2><p>ADC（Analog-Digital Converter）模拟-数字转换器可以将引脚上连续变化的模拟电压转换为内存中存储的数字变量。</p>
<p>STM32系列上的完整ADC是12<sup>1</sup>位逐次逼近型ADC，转换时间为$1us$（即AD频率<sup>2</sup>为$1MHz$），其输入电压范围：0<del>3.3V，转换结果（模拟 - 数字量）范围：0</del>4095（$2^{12}-1$），有18个输入通道，可测量16个外部（GPIO）和2个内部信号源（内部温度传感器<sup>3</sup>和内部参考电压<sup>4</sup>），并拥有，规则组和注入组两个转换单元，支持模拟看门狗自动监测输入电压范围。</p>
<p>STM32F103C8T6的ADC资源：ADC1、ADC2，10个外部输入通道。</p>
<hr>
<p><sup>1</sup>:即 ADC 分辨率，12位分辨率体现在转换结果的范围就是 0~4095（$2^{12}-1$）分辨率越高，精度就越高。<br><sup>2</sup>：AD 频率需要大于模拟信号的频率才能保持精度。<br><sup>3</sup>:  主要用于测量 CPU 温度<br><sup>4</sup>:  3V3供电的情况下大约在1.2V,主要起校准作用</p>
<h2 id="13-2-一般-ADC-工作原理"><a href="#13-2-一般-ADC-工作原理" class="headerlink" title="13.2 一般 ADC 工作原理"></a>13.2 一般 ADC 工作原理</h2><p>ADC 含有多条输入通道，通过译码器来控制选取。在选择好输入通道之后，采集的电压信号进入比较器，与内部DAC（通过加权电阻网络实现）输出的电压信号比较。比较器会根据比较结果来输出高低电平。调整DAC的输入量，直到DAC输出电压与外部输入电压近似相等，此时DAC输入量就是外部输入（A）的编码数据（D）了。这个调整的过程是通过逐次逼近寄存器<code>SAR</code> 完成的。</p>
<p>为了最快找到这个编码量，通常采用二分法来进行操作。对最大转换量进行逐次二分，观察每次比较器的情况。由于逐次二分的量满足 $&#x3D;2^n$ 的关系，恰好是二进制每一位的位权，所以二分法逐次逼近的过程就是对二进制量从高位到低位的逐次比较过程，通过依次判断每一位是 1 还是 0 （即比较器中的大小关系），就可以缩小所需编码数据的确切范围。</p>
<p>DAC的输入量可以通过锁存缓冲器进行输出，输出通道与输入通道数量保持一致。</p>
<p><code>SCR</code>的上游控制是<code>CLOCK</code>ADC时钟与<code>START</code>开始转换信号。当转换完成后，会通过<code>EOC(End Of Convert)</code>来输出转换完成信号。</p>
<p>DAC 会接入内部参考电压 $V_{REF±}$ ，这个电压决定了ADC的输入范围。</p>
<h2 id="13-3-STM32中的ADC"><a href="#13-3-STM32中的ADC" class="headerlink" title="13.3 STM32中的ADC"></a>13.3 STM32中的ADC</h2><h3 id="13-3-1-输入通道选取"><a href="#13-3-1-输入通道选取" class="headerlink" title="13.3.1 输入通道选取"></a>13.3.1 输入通道选取</h3><p>STM32中，ADC通道为<code>ADCx_Inx</code>,还有内部温度传感器和参考电压  $V_{REFINT}$ . 有别于上面提到的译码器控制，STM32有多路选择器，可以同时选择多路输入，并分为规则组和注入组。</p>
<p>规则组可以选择16个通道，但是对应的数据寄存器只能存放一个的转换结果，需要在转换结果完成后立马提取转换值，以免被后来的转换值覆盖，或者配合<code>DMA</code>来使用。</p>
<p>注入组可以选择4个通道，并且对应的数据寄存器可以存放全部4个通道的转换结果。</p>
<table>
<thead>
<tr>
<th>通道</th>
<th>ADC1</th>
<th>ADC2</th>
<th>ADC3(C8T6没有)</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>通道0</td>
<td>PA0</td>
<td>PA0</td>
<td>PA0</td>
<td></td>
</tr>
<tr>
<td>通道1</td>
<td>PA1</td>
<td>PA1</td>
<td>PA1</td>
<td></td>
</tr>
<tr>
<td>通道2</td>
<td>PA2</td>
<td>PA2</td>
<td>PA2</td>
<td></td>
</tr>
<tr>
<td>通道3</td>
<td>PA3</td>
<td>PA3</td>
<td>PA3</td>
<td></td>
</tr>
<tr>
<td>通道4</td>
<td>PA4</td>
<td>PA4</td>
<td>PF6</td>
<td></td>
</tr>
<tr>
<td>通道5</td>
<td>PA5</td>
<td>PA5</td>
<td>PF7</td>
<td></td>
</tr>
<tr>
<td>通道6</td>
<td>PA6</td>
<td>PA6</td>
<td>PF8</td>
<td></td>
</tr>
<tr>
<td>通道7</td>
<td>PA7</td>
<td>PA7</td>
<td>PF9</td>
<td></td>
</tr>
<tr>
<td>通道8</td>
<td>PB0</td>
<td>PB0</td>
<td>PF10</td>
<td></td>
</tr>
<tr>
<td>通道9</td>
<td>PB1</td>
<td>PB1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>通道10</td>
<td>PC0</td>
<td>PC0</td>
<td>PC0</td>
<td></td>
</tr>
<tr>
<td>通道11</td>
<td>PC1（C8T6没有）</td>
<td>PC1（C8T6没有）</td>
<td>PC1</td>
<td></td>
</tr>
<tr>
<td>通道12</td>
<td>PC2（C8T6没有）</td>
<td>PC2（C8T6没有）</td>
<td>PC2</td>
<td></td>
</tr>
<tr>
<td>通道13</td>
<td>PC3（C8T6没有）</td>
<td>PC3（C8T6没有）</td>
<td>PC3</td>
<td></td>
</tr>
<tr>
<td>通道14</td>
<td>PC4（C8T6没有）</td>
<td>PC4（C8T6没有）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>通道15</td>
<td>PC5（C8T6没有）</td>
<td>PC5（C8T6没有）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>通道16</td>
<td>温度传感器</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>通道17</td>
<td>内部参考电压</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<hr>
<p>表：输入通道对应 GPIO 引脚关系</p>
<h3 id="13-3-4-开始转换信号-ADC-时钟"><a href="#13-3-4-开始转换信号-ADC-时钟" class="headerlink" title="13.3.4 开始转换信号 &#x2F; ADC 时钟"></a>13.3.4 开始转换信号 &#x2F; ADC 时钟</h3><p>开始转换信号可以由软件或者硬件提供。软件触发需要调用函数，而硬件触发则由定时器来提供触发源，规则组和注入组的触发源不同。</p>
<p>信号具有不同的转换模式，转换模式根据 是否连续转换 以及 扫描模式 这两个参数来决定具体的转换方式。</p>
<table>
<thead>
<tr>
<th>连续情况 &#x2F; 扫描模式</th>
<th>非扫描</th>
<th>扫描</th>
</tr>
</thead>
<tbody><tr>
<td>单次转换</td>
<td>只开放一个通道，转换完就停止</td>
<td>多通道同左</td>
</tr>
<tr>
<td>连续转换</td>
<td>只开放一个通道，转换完成立刻开始下一次转换</td>
<td>多通道同左</td>
</tr>
</tbody></table>
<p>ADC 逐次逼近的时钟是<code>ADCCLK</code>由ADC预分频器提供，这个分频器在RCC内部，通过这个分频器对 <code>APB2</code> 时钟进行分频就得到ADC的时钟了。ADC预分频器支持<code>2,4,6,8</code>分频，而<code>ADCCLK</code>允许的最大值为 $14Mhz$ ,而 <code>APB2</code> 内部时钟是 $72Mhz$，所以只能选择<code>6,8</code>分频。 </p>
<h3 id="13-3-5-数据输出"><a href="#13-3-5-数据输出" class="headerlink" title="13.3.5 数据输出"></a>13.3.5 数据输出</h3><p>规则组有一条<code>DMA</code>请求通道，用于联系<code>DMA</code>完成输出数据转运。输出数据寄存器旁设置有模拟看门狗，通过设置阈值高低限并指定监测通道，当通道超过阈值，模拟看门狗就会发送即<code>AWD</code>信号。规则组和注入组在完成转换后也会发送 <code>EOC</code>和 <code>JEOC</code>信号，并置标志位。</p>
<p>这三个信号都可继续发送至<code>NVIC</code>的<code>ADC</code>中断请求，通过中断使能位<code>EOCIE</code>，<code>JEOCIE</code>,<code>AWDIE</code>完成。</p>
<p>输出数据寄存器是16位的，但ADC输出量是12位的。12位数据在16位的寄存器中有右对齐和左对齐两种方式，分别对应高位补0和低位补0，一般使用右对齐，因为右对齐的输出数据就是一般形式，使用左对齐输出的数据是大<code>16</code>倍的（左移4位，二进制数据增大$2^n$倍）。</p>
<p>左对齐一般用于提取高位数据来降低分辨率。</p>
<h3 id="13-3-6-其他"><a href="#13-3-6-其他" class="headerlink" title="13.3.6 其他"></a>13.3.6 其他</h3><p>AD转换的步骤是：采样，保持，量化，编码。由于量化编码（即逐次逼近）需要时间，所以需要采样保持电路来存储当前的电压波形。</p>
<p>STM32 ADC的总转换时间为：<br>$$T_{CONV} &#x3D; 采样时间 + 12.5个ADC周期$$<br>其中 $T_{CONV}$ 为总转换时间，$12.5$ 为处理12位分辨率所需时间加上0.5个其他步骤时间，<code>ADC</code><br>周期为<code>ADCCLK</code>。</p>
<blockquote>
<p>例如：当ADCCLK&#x3D;14MHz，采样时间为1.5个ADC周期<br>   $T_{CONV} &#x3D; (1.5 + 12.5)*ADCCLK &#x3D; 1μs$</p>
</blockquote>
<h2 id="13-4-Code：AD单通道"><a href="#13-4-Code：AD单通道" class="headerlink" title="13.4 Code：AD单通道"></a>13.4 Code：AD单通道</h2><h3 id="13-4-1-硬件电路配置及代码原理"><a href="#13-4-1-硬件电路配置及代码原理" class="headerlink" title="13.4.1 硬件电路配置及代码原理"></a>13.4.1 硬件电路配置及代码原理</h3><p>电位器（左负右正）正极连接单片机的<code>3V3</code>供电，负极与单片机共地。使用ADC1通道0来采集电位器的电压，电位器的输出端连接至引脚<code>PA0</code>. 旋转电位器，则电位器两端电压就会发生变化，所所采集到的电压应当在<code>0</code>到<code>3V3</code>之间变化. 电位器电压是模拟信号，采集模拟信号之后由<code>ADC</code>输出转换量<code>AD_Value</code>,通过线性变换将转换量映射为电压<code>Voltage</code>，将这两个参数显示在<code>OLED</code>屏幕上。</p>
<h3 id="13-4-2-ADC-Init-AD转换初始化"><a href="#13-4-2-ADC-Init-AD转换初始化" class="headerlink" title="13.4.2 ADC_Init - AD转换初始化"></a>13.4.2 ADC_Init - AD转换初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADConvert_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">	</span><br><span class="line">	RCC_ADCCLKConfig(RCC_PCLK2_Div6);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	ADC_RegularChannelConfig(ADC1,ADC_Channel_0,<span class="number">1</span>,ADC_SampleTime_55Cycles5);</span><br><span class="line">	</span><br><span class="line">	ADC_InitTypeDef ADC_InitStructure;</span><br><span class="line">	ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;</span><br><span class="line">	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;</span><br><span class="line">	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;</span><br><span class="line">	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;</span><br><span class="line">	ADC_InitStructure.ADC_NbrOfChannel = <span class="number">1</span>;</span><br><span class="line">	ADC_InitStructure.ADC_ScanConvMode = DISABLE;</span><br><span class="line">	</span><br><span class="line">	ADC_Init(ADC1,&amp;ADC_InitStructure);</span><br><span class="line">	</span><br><span class="line">	ADC_Cmd(ADC1,ENABLE);</span><br><span class="line">	</span><br><span class="line">	ADC_ResetCalibration(ADC1);</span><br><span class="line">	<span class="keyword">while</span>(ADC_GetResetCalibrationStatus(ADC1) == SET);</span><br><span class="line">	ADC_StartCalibration(ADC1);</span><br><span class="line">	<span class="keyword">while</span>(ADC_GetCalibrationStatus(ADC1) == SET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="title function_">Get_ADCValue</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ADC_SoftwareStartConvCmd(ADC1,ENABLE);</span><br><span class="line">	<span class="keyword">while</span>(ADC_GetFlagStatus(ADC1,ADC_FLAG_EOC) == RESET);</span><br><span class="line">	<span class="keyword">return</span> ADC_GetConversionValue(ADC1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>函数名字不叫<code>ADC_Init</code>是因为这是一个保留名。<code>ADC_Init</code>是用来初始化 ADC 的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line"></span><br><span class="line">RCC_ADCCLKConfig(RCC_PCLK2_Div6);</span><br></pre></td></tr></table></figure>

<p>首先来配置<code>RCC</code>部分。<code>ADC</code>都是挂载在<code>APB2</code>总线上的，而<code>ADC</code>需要<code>GPIOA</code>作为模拟信号输入引脚，所以时钟开启部分需要开启<code>APB2</code>上<code>ADC</code>和<code>GPIOA</code>的时钟。</p>
<p>这之后，由于经过预分频后才能得到<code>ADCCLK</code>,而<code>ADC</code>预分频器在<code>RCC</code>内，所以此处调用<code>ADCCLK</code>设置函数<code>void RCC_ADCCLKConfig(uint32_t RCC_PCLK2)</code>进行分频得到<code>ADCCLK</code>。函数的参数只有一个<code>RCC_PCLK2</code>,表示对标准时钟频率 $72MHz$ 进行分频的分值。由于目标<code>ADCCLK</code>要求最高为 $14Mhz$，所以这里配置为<code>RCC_PCLK2_Div6</code>，表示对标准时钟频率进行<code>6</code>分频，最终得到的<code>ADCCLK</code>为 $12MHz$，也就是<code>ADC</code>周期。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br></pre></td></tr></table></figure>

<p><code>PA0</code>是作为模拟输入的引脚，此时其作为<code>GPIO</code>的功能失效。在模式配置<code>GPIO_Mode</code>这里需要配置为模拟输入模式<code>GPIO_Mode_AIN</code>。其他照旧。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_0,<span class="number">1</span>,ADC_SampleTime_55Cycles5);</span><br><span class="line"></span><br><span class="line">ADC_InitTypeDef ADC_InitStructure;</span><br><span class="line">ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;</span><br><span class="line">ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;</span><br><span class="line">ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;</span><br><span class="line">ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;</span><br><span class="line">ADC_InitStructure.ADC_NbrOfChannel = <span class="number">1</span>;</span><br><span class="line">ADC_InitStructure.ADC_ScanConvMode = DISABLE;</span><br><span class="line"></span><br><span class="line">ADC_Init(ADC1,&amp;ADC_InitStructure);</span><br><span class="line"></span><br><span class="line">ADC_Cmd(ADC1,ENABLE);</span><br></pre></td></tr></table></figure>

<p>开启时钟，预分频<code>ADC</code>时钟并配置<code>PA0</code>为模拟输入引脚之后，开始配置<code>ADC</code>模式。</p>
<p>首先调用函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_RegularChannelConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> ADC_Channel, <span class="type">uint8_t</span> Rank, <span class="type">uint8_t</span> ADC_SampleTime)</span></span><br></pre></td></tr></table></figure>

<p>进行ADC通道选择及其相关参数的配置。</p>
<p><code>ADCx</code>，表示选中执行操作的<code>ADC</code>，这里是<code>ADC1</code>。</p>
<p><code>ADC_Channel</code>为选中的通道，由于已经连接到了<code>PA0</code>,这里选择通道0, <code>ADC_Channel_0</code>. </p>
<p>接下来<code>Rank</code>表示选中通道进行转换的次序，由于这里只需要采集电位器一路电压，所以直接写<code>1</code>，表示第一个进行转换。实际上由于这里根据预期功能，使用规则组，单次转换非扫描的转换模式，所以永远只会开放一个通道，次序也就只有第一个了。</p>
<p><code>ADC_SampleTime</code>是采样时间，会影响到最终的总转换时间。采集电位器的电压暂时没有特别的精度需求，这里可以配置成<code>ADC_SampleTime_55Cycles5</code>,表示采样时间为<code>55</code>个<code>ADC</code>周期。</p>
<p>于是最终的通道配置与参数配置可以如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_0,<span class="number">1</span>,ADC_SampleTime_55Cycles5);</span><br></pre></td></tr></table></figure>

<p>在配置好通道的相关信息后，就继续初始化<code>ADC</code>的输出配置。</p>
<p><code>ADC_InitStructure.ADC_ContinuousConvMode</code>表示转换的连续情况，这里配置为单次转换就可以，即<code>DISABLE</code>禁用连续转换。</p>
<p><code>ADC_DataAlign</code>代表数据对齐方式，一般直接配置为右对齐<code>ADC_DataAlign_Right</code>.</p>
<p><code>ADC_InitStructure.ADC_ExternalTrigConv</code>代表外部触发源选择。这里直接采用软件触发源，不使用外部触发，所以配置为<code>ADC_ExternalTrigConv_None</code>表示不使用。</p>
<p><code>ADC_Mode</code>代表<code>ADC</code>是单个使用还是成对使用。成对使用的情况下<code>ADC1</code>和<code>ADC2</code>都参与带那样的采集，有利于提高精度。但是在这里需求不大，直接配置为<code>ADC_Mode_Independent</code>就表示是一个<code>ADC</code>单独作用。</p>
<p><code>ADC_NbrOfChannel</code>代表进行输出的通道的数目。由于采用了非扫描模式，只开放了一个通道，所以也是写<code>1</code>就行。</p>
<p><code>ADC_InitStructure.ADC_ScanConvMode = DISABLE;</code>代表扫描模式使能，采用非扫描模式直接<code>DISABLE</code>禁用扫描模式。</p>
<p>参数配置完设置后初始化<code>ADC</code>输出，并用函数<code>ADC_Cmd</code>来使能<code>ADC</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ADC_ResetCalibration(ADC1);</span><br><span class="line"><span class="keyword">while</span>(ADC_GetResetCalibrationStatus(ADC1) == SET);</span><br><span class="line">ADC_StartCalibration(ADC1);</span><br><span class="line"><span class="keyword">while</span>(ADC_GetCalibrationStatus(ADC1) == SET);</span><br></pre></td></tr></table></figure>

<p><code>ADC</code>输入输出都配置好了以后，需要对<code>ADC</code>进行校准。校准分为两个步骤，一是复位校准，二是开始校准。</p>
<p>复位校准首先调用函数<code>ADC_ResetCalibration</code>于<code>ADC1</code>开始复位校准的过程。复位校准未结束前，复位校准标志位都会置<code>SET</code>.此时调用函数<code>ADC_GetResetCalibrationStatus</code>来获取这个标志位，当始终为<code>SET</code> 时说明未复位完成，在while循环中等待就可以。</p>
<p>开始校准也是一样的流程，只是函数的名字变了。</p>
<h3 id="13-4-4-获取转换量"><a href="#13-4-4-获取转换量" class="headerlink" title="13.4.4 获取转换量"></a>13.4.4 获取转换量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="title function_">Get_ADCValue</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ADC_SoftwareStartConvCmd(ADC1,ENABLE);</span><br><span class="line">	<span class="keyword">while</span>(ADC_GetFlagStatus(ADC1,ADC_FLAG_EOC) == RESET);</span><br><span class="line">	<span class="keyword">return</span> ADC_GetConversionValue(ADC1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>13.4.3 中只是初始化了<code>ADC</code>，准备好了<code>AD</code>的所有条件，但是还没有开始转换。开始转换由于开始触发源已经配置为软件触发，所以第一步就是调用函数<code>ADC_SoftwareStartConvCmd</code>.</p>
<p>这个函数的调用作为软件触发源发送转换的开始信号。</p>
<p>由于转换量只有在转换完成后才能读取，所以需要等待转换结束。转换结束时，函数<code>ADC_GetFlagStatus</code>将会返回<code>SET</code>,所以当函数返回<code>RESET</code> 时就代表转换未完成，同样用<code>while</code>循环等待。</p>
<p>函数<code>ADC_GetConversionValue</code>用于获取转换量。</p>
<h3 id="13-4-5-主函数"><a href="#13-4-5-主函数" class="headerlink" title="13.4.5 主函数"></a>13.4.5 主函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ADC.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> ADC_Value;</span><br><span class="line"><span class="type">float</span> Voltage;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">		ADConvert_Init();</span><br><span class="line">		OLED_Init();</span><br><span class="line">		OLED_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;ADCValue:&quot;</span>);</span><br><span class="line">		OLED_ShowString(<span class="number">2</span>,<span class="number">1</span>,<span class="string">&quot;Voltage:0.00V&quot;</span>);</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">			ADC_Value = Get_ADCValue();</span><br><span class="line">			Voltage = (<span class="type">float</span>)ADC_Value / <span class="number">4095</span> * <span class="number">3.3</span>;</span><br><span class="line">			OLED_ShowNum(<span class="number">1</span>,<span class="number">10</span>,ADC_Value,<span class="number">4</span>);</span><br><span class="line">			OLED_ShowNum(<span class="number">2</span>,<span class="number">9</span>,Voltage,<span class="number">1</span>);</span><br><span class="line">			OLED_ShowNum(<span class="number">2</span>,<span class="number">11</span>,(<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span>)(Voltage * <span class="number">100</span>) % <span class="number">100</span>,<span class="number">2</span>);</span><br><span class="line">			</span><br><span class="line">			Delay_ms(<span class="number">100</span>);</span><br><span class="line">		&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数读取转换值，并将其映射为电压，通过<code>OLED</code>进行显示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> ADC_Value;</span><br><span class="line"><span class="type">float</span> Voltage;</span><br></pre></td></tr></table></figure>

<p>由于电位器的正极连接到<code>3V3</code>,所以采集电压的类型是个浮点数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ADC_Value = Get_ADCValue();</span><br><span class="line">Voltage = (<span class="type">float</span>)ADC_Value / <span class="number">4095</span> * <span class="number">3.3</span>;</span><br><span class="line">OLED_ShowNum(<span class="number">1</span>,<span class="number">10</span>,ADC_Value,<span class="number">4</span>);</span><br><span class="line">OLED_ShowNum(<span class="number">2</span>,<span class="number">9</span>,Voltage,<span class="number">1</span>);</span><br><span class="line">OLED_ShowNum(<span class="number">2</span>,<span class="number">11</span>,(<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span>)(Voltage * <span class="number">100</span>) % <span class="number">100</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>电压与转换量的映射关系为：</p>
<p>$$Voltage &#x3D; \frac{AD\space Value}{Resolution-1} * Voltage_{Max} $$</p>
<p>即电压占<code>3V3</code>的比例为转换值占最大转换量（即分辨率-1得到精度）的比例。前面知道本<code>ADC</code>为12位<code>ADC</code>：</p>
<p>$$Resolution &#x3D; 2^{12} &#x3D; 4096$$</p>
<p>算式中转换量需要强制类型转换为浮点数，不然除法会失去精度。</p>
<p>由于电压是浮点数，而目前封装好的<code>OLED</code>显示函数不包括浮点数显示，所以此处需要单独取电压值的整数位和小数位。整数位限制显示数字的<code>1</code>位就可以得到，而小数部分需要将电压值放大<code>100</code>倍后对<code>100</code>取模，得到放大为整数的小数部分。最后通过强制类型转换为整数来规避<code>float</code>类型的更多影响。</p>
<p>最后加的延时函数则是延缓了显示数据的跳变，看着清楚一点。</p>
<h3 id="13-4-6-拓展：启用连续转换"><a href="#13-4-6-拓展：启用连续转换" class="headerlink" title="13.4.6 拓展：启用连续转换"></a>13.4.6 拓展：启用连续转换</h3><p>假设启用连续转换，那么也可以完成上述功能。只需要在<code>ADConvert_Init</code>中配置连续转换，再把<code>Get_ADCValue()</code>里面发送开始信号的函数挪到<code>ADConvert_Init</code>中就可以。连续转换的情况下，只需要在主函数的<code>while</code>循环外发送一次开始信号，硬件就会自动进行下一次的转换，这时候硬件会自动清除标志位，所以<code>Get_ADCValue()</code>中的<code>while</code>循环等待也可以删除。</p>
<h2 id="13-5-Code-伪AD多通道"><a href="#13-5-Code-伪AD多通道" class="headerlink" title="13.5 Code: 伪AD多通道"></a>13.5 Code: 伪AD多通道</h2><p>一般而言，使用多通道采集多个模拟信号是需要开启多个通道的，也就是需要开启扫描模式。但是多通道模式的情况下，单个通道转换完的转换量很快就会被下个通道覆盖，而且只有全部通道都转换完，<code>ADC</code>才会记一次转换完成位，这样就很难判断单通道转换的情况，不便于及时读取并储存数据。多通道的情况下一般是要配合<code>DMA</code>来使用的。</p>
<p>实际上，用上面<code>AD</code>单通道代码中的单次转换，非扫描转换模式也可以完成多通道的任务，思路是在完成单次转换后，将转换值存储到变量中，并手动改变选取的通道，这样下一次单次转换的转换值就是不同通道的了。这样的操作从效果上看与多通道是等效的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3;</span><br></pre></td></tr></table></figure>

<p>首先初始化函数中只需要把<code>GPIO</code>的数量拓展一下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="title function_">Get_ADCValue</span><span class="params">(<span class="type">unint8_t</span> ADC_Channel)</span></span><br><span class="line">&#123;</span><br><span class="line">	ADC_RegularChannelConfig(ADC1,ADC_Channel,<span class="number">1</span>,ADC_SampleTime_55Cycles5);</span><br><span class="line">	ADC_SoftwareStartConvCmd(ADC1,ENABLE);</span><br><span class="line">	<span class="keyword">while</span>(ADC_GetFlagStatus(ADC1,ADC_FLAG_EOC) == RESET);</span><br><span class="line">	<span class="keyword">return</span> ADC_GetConversionValue(ADC1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把只会调用一次的<code>ADConvert_Init</code>中的通道选择函数挪到<code>Get_ADCValue</code>中，并设置入口参数为<code>unint8_t ADC_Channel</code>,这个参数已经定义好了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		AD0 = Get_ADCValue(ADC_Channel_0);		<span class="comment">//单次启动ADC，转换通道0</span></span><br><span class="line">		AD1 = Get_ADCValue(ADC_Channel_1);		<span class="comment">//单次启动ADC，转换通道1</span></span><br><span class="line">		AD2 = Get_ADCValue(ADC_Channel_2);		<span class="comment">//单次启动ADC，转换通道2</span></span><br><span class="line">		AD3 = Get_ADCValue(ADC_Channel_3);		<span class="comment">//单次启动ADC，转换通道3</span></span><br><span class="line">		</span><br><span class="line">		OLED_ShowNum(<span class="number">1</span>, <span class="number">5</span>, AD0, <span class="number">4</span>);				<span class="comment">//显示通道0的转换结果AD0</span></span><br><span class="line">		OLED_ShowNum(<span class="number">2</span>, <span class="number">5</span>, AD1, <span class="number">4</span>);				<span class="comment">//显示通道1的转换结果AD1</span></span><br><span class="line">		OLED_ShowNum(<span class="number">3</span>, <span class="number">5</span>, AD2, <span class="number">4</span>);				<span class="comment">//显示通道2的转换结果AD2</span></span><br><span class="line">		OLED_ShowNum(<span class="number">4</span>, <span class="number">5</span>, AD3, <span class="number">4</span>);				<span class="comment">//显示通道3的转换结果AD3</span></span><br><span class="line">		</span><br><span class="line">		Delay_ms(<span class="number">100</span>);			<span class="comment">//延时100ms，手动增加一些转换的间隔时间</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>在主函数中<code>while</code>循环内反复调用<code>Get_ADCValue</code>，每次修改入口参数为不同的通道，就可以实现一次循环获取四个不同通道的转换量并进行显示，以达到多通道的等效效果。</p>
<h1 id="14-DMA-直接储存器存取"><a href="#14-DMA-直接储存器存取" class="headerlink" title="14. DMA 直接储存器存取"></a>14. DMA 直接储存器存取</h1><p>DMA（Direct Memory Access）直接存储器存取可以提供外设（外设的数据寄存器<code>Data Register</code>,比如<code>ADC</code>的数据存储寄存器）和存储器或者存储器和存储器之间的高速数据传输，无须CPU干预，节省了CPU的资源。</p>
<p>STM32系列最多有12个独立可配置的通道： DMA1（7个通道）， DMA2（5个通道）<br>，每个通道都支持软件触发和特定的硬件触发。</p>
<p>STM32F103C8T6 DMA资源：DMA1（7个通道）。</p>
<p>DMA可以直接访问STM32中的存储器，包括运行内存<code>SRAM</code>,程序存储器<code>FLASH</code>,一般寄存器等等。</p>
<h2 id="14-1-存储器"><a href="#14-1-存储器" class="headerlink" title="14.1 存储器"></a>14.1 存储器</h2><p>计算机设备的五大组成部分一般是运算器、控制器、存储器，输入和输出设备。运算器和控制器一般组成<code>CPU</code>。计算机的核心部分就是<code>CPU</code>和存储器。</p>
<p>存储器的两大要素是存储器的内容以及地址。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>起始地址</th>
<th>存储器</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>ROM（只读存储器）</td>
<td>0x0800 0000<br><br><br>0x1FFF F000<br><br>0x1FFF F800</td>
<td>程序存储Flash<br><br>系统存储器<br><br>选项字节</td>
<td>存储C语言编译后的程序代码|<br><br><br>存储BootLoader，用于串口下载<br><br>存储一些独立于程序代码的配置参数</td>
</tr>
<tr>
<td>RAM</td>
<td>0x2000 0000<br><br><br>0x4000 0000<br><br>0xE000 0000</td>
<td>运行内存SRAM<br><br>外设寄存器<br><br>内核外设寄存器</td>
<td>存储运行过程中的临时变量（程序中自己定义的变量、数组等）<br><br>存储各个外设的配置参数<br><br>存储内核各个外设的配置参数</td>
</tr>
</tbody></table>
<p>在STM32中，存储器分配到的地址从<code>0x0000 0000</code> 到<code>0xFFFF FFFF</code>,这表明是32位寻址，可以支持4GB容量的存储器。</p>
<p>通过吧程序映射到不同的存储器区，就可以实现不同的启动方式，比如<code>FLASH</code>区启动，系统存储器区配置<code>Boot Loader</code>启动,<code>SRAM</code>启动。</p>
<p>寄存器是一种特殊的存储器，CPU可以访问寄存器进行读写，而寄存器的每一位也可以控制外设电路的状态，比如置引脚的高低电平，断开或开启开关，切换数据选择器等等。</p>
<h2 id="14-2-DMA-结构"><a href="#14-2-DMA-结构" class="headerlink" title="14.2 DMA 结构"></a>14.2 DMA 结构</h2><p><code>DMA</code>中含有多个 <code>DMA</code>通道,可以分别设置转运数据的源地址和目标地址。但是由于<code>DMA</code>只有一条总线去访问存储器，所以多个通道需要分时复用。</p>
<p><code>DMA</code>中的仲裁器会根据每个通道的优先级来决定先后次序，类似<code>NVIC</code>。在外部总线矩阵处也会有仲裁器，让<code>CPU</code>和<code>DMA</code>相遇时候<code>CPU</code>先停止访问，<code>DMA</code>先转运数据以防止冲突。此时<code>CPU</code>仍然会分配有一半的总线带宽，所以也可以正常工作。</p>
<p><code>DMA</code>自身也有寄存器，即<code>AHB</code>从设备，<code>AHB</code>相当于<code>DMA</code>的外设配置寄存器,<code>CPU</code>通过访问<code>AHB</code>总线就可以配置<code>DMA</code>了。</p>
<p><code>DMA</code>转运数据需要接受<code>DMA</code>请求，这个请求可以由外设发出，作为<code>DMA</code>的硬件触发源。</p>
<h2 id="14-3-DMA-原理"><a href="#14-3-DMA-原理" class="headerlink" title="14.3 DMA 原理"></a>14.3 DMA 原理</h2><p><code>DMA</code>转运数据的类型一般有存储器（主要是<code>FLASH</code> 和 <code>SRAM</code>）与外设寄存器之间的相互转运以及存储器之间的相互转运。由于<code>FLASH</code>是<code>ROM</code>，所以不能完成目的为<code>FLASH</code>的转运操作。</p>
<p>为了完善转运数据的详细情况，外设寄存器和存储器都各自有三个参数：起始地址，数据宽度，地址是否自增。起始地址定了转运数据的源地址和目的地址，数据宽度指定了一次转运数据的数据宽度，比如<code>Byte</code>字节，<code>HalfWord</code>半字和  <code>Word</code>字，大小分别对应<code>8,16,32</code>位。地址是否自增指定了一次转运完成后，是否在下一个地址开始转运，比如 <code>ADC</code>数据存储器的地址是固定的，不需要自增，但是存储器中用于储存每次数据的地址是唯一的，也就是需要自增，否则数据会被覆盖。</p>
<p>如果要实现存储器之间的相互转运，可以将外设寄存器的起始地址改为<code>SRAM</code>或<code>FLASH</code>。<br>同理，存储器和外设之间的转运方向也可以调换，只是在编写程序时固定转出端的命名为外设寄存器，而输入端为存储器了，实际上通过修改起始地址就可以完成任意（除只读）的数据转运。</p>
<p><code>DMA</code>的传输次数由传输计数器指定，这是一个自减计数器，一轮转运中每转运一次计数值就会减少，直到 0 停止转运并复位自增的地址。而传输计数器还受到自动重装器的控制，自动重装器用于指定传输计数器为 0 之后是否开始下一轮转运。比如转运一个数组只需要一轮转运，而<code>ADC</code>的连续扫描转换就需要多轮转运。</p>
<p><code>DMA</code>的触发模式由<code>M2M (Memory to Memory)</code>控制。软件触发会连续、自动地触发<code>DMA</code>，以最快速度清零传输计数器，这时候就不能使用自动重装器了，否则<code>DMA</code>根本停不下来。软件触发适用于存储器到存储器这样无关时机、越快越好的转运需求，所以在配置软件触发时 ，<code>M2M</code>是置 1 的。硬件触发则需要等待某个时机，也就是硬件完成了某个动作，发送<code>DMA</code>请求，<code>M2M</code>置 0 启动。每个<code>DMA</code>通道的硬件触发源不同，软件触发都一样。</p>
<p>传输计数器清0后，必须关闭<code>DMA</code>写新的值才可以继续开启。不可以在<code>DMA</code>开启的时候写传输计数器。</p>
<h2 id="14-4-Code：DMA-存储器与存储器-数组值转运"><a href="#14-4-Code：DMA-存储器与存储器-数组值转运" class="headerlink" title="14.4 Code：DMA 存储器与存储器 - 数组值转运"></a>14.4 Code：DMA 存储器与存储器 - 数组值转运</h2><p>定义两个数组<code>Data_Source</code>和<code>Data_Destination</code>作为转运数据的起点和终点。这两个数组都属于变量，所以都是存储在<code>SRAM</code>中的。如果需要从<code>FLASH</code>中转运数据，那么需要将<code>Data_Source</code>加上<code>const</code>关键字表示只读。</p>
<p>既然是从<code>SRAM</code>转运数据去<code>SRAM</code>，那么就需要使用软件触发。</p>
<h3 id="14-4-1-DMA-启动配置"><a href="#14-4-1-DMA-启动配置" class="headerlink" title="14.4.1 DMA 启动配置"></a>14.4.1 DMA 启动配置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> DMA_reSize;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMACfg_Init</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> SAddr,<span class="type">unsigned</span> <span class="type">int</span> DAddr,<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	DMA_reSize = size;</span><br><span class="line">	</span><br><span class="line">	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);</span><br><span class="line">	</span><br><span class="line">	DMA_InitTypeDef DMA_InitStructure;</span><br><span class="line">	DMA_InitStructure.DMA_PeripheralBaseAddr = SAddr;</span><br><span class="line">	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;</span><br><span class="line">	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Enable;</span><br><span class="line">	</span><br><span class="line">	DMA_InitStructure.DMA_MemoryBaseAddr = DAddr;</span><br><span class="line">	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;</span><br><span class="line">	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;</span><br><span class="line">	</span><br><span class="line">	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;</span><br><span class="line">	DMA_InitStructure.DMA_BufferSize = size;</span><br><span class="line">	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;</span><br><span class="line">	DMA_InitStructure.DMA_M2M = DMA_M2M_Enable;</span><br><span class="line">	DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;</span><br><span class="line">	</span><br><span class="line">	DMA_Init(DMA1_Channel1,&amp;DMA_InitStructure);</span><br><span class="line">	</span><br><span class="line">	DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMACfg_Retransfer</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	DMA_Cmd(DMA1_Channel1,DISABLE);</span><br><span class="line">	DMA_SetCurrDataCounter(DMA1_Channel1,DMA_reSize);</span><br><span class="line">	DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(DMA_GetFlagStatus(DMA1_FLAG_TC1) == RESET);</span><br><span class="line">	DMA_ClearFlag(DMA1_FLAG_TC1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> DMA_reSize;</span><br></pre></td></tr></table></figure>

<p>定义静态全局变量<code>DMA_reSize</code>表示传输计数器清 0 后下一轮转运的值。静态关键字表明该变量的作用于只在本文件里，不会影响其他函数。第一次传参进来之后<code>DMA_reSize</code>就会被赋值，然后之后的转运轮次都根据<code>DMA_reSize</code>决定。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DMACfg_Init</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> SAddr,<span class="type">unsigned</span> <span class="type">int</span> DAddr,<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	DMA_reSize = size;</span><br><span class="line">	</span><br><span class="line">	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);</span><br><span class="line">	</span><br><span class="line">	DMA_InitTypeDef DMA_InitStructure;</span><br><span class="line">	DMA_InitStructure.DMA_PeripheralBaseAddr = SAddr;</span><br><span class="line">	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;</span><br><span class="line">	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Enable;</span><br><span class="line">	</span><br><span class="line">	DMA_InitStructure.DMA_MemoryBaseAddr = DAddr;</span><br><span class="line">	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;</span><br><span class="line">	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;</span><br><span class="line">	</span><br><span class="line">	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;</span><br><span class="line">	DMA_InitStructure.DMA_BufferSize = size;</span><br><span class="line">	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;</span><br><span class="line">	DMA_InitStructure.DMA_M2M = DMA_M2M_Enable;</span><br><span class="line">	DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;</span><br><span class="line">	</span><br><span class="line">	DMA_Init(DMA1_Channel1,&amp;DMA_InitStructure);</span><br><span class="line">	</span><br><span class="line">	DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义函数<code>void DMACfg_Init(unsigned int SAddr,unsigned int DAddr,unsigned short int size)</code>不使用<code>DMA_Init</code>命名也是因为保留名问题。</p>
<p>函数的参数<code>unsigned int SAdd</code>表示转运的起始地址，<code>unsigned int DAddr</code>表示转运的目的地址，<code>short int size</code>表示第一轮转运的次数，这个值稍后即会赋给<code>DMA_reSize</code>作为第一轮结束后下轮的转运次数。即第一次传参的次数就是<code>DMA</code>每轮转运的次数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);</span><br></pre></td></tr></table></figure>

<p><code>RCC</code>部分，由于<code>DMA</code>是挂载在<code>AHB</code>总线上的外设，所以需要开启<code>AHB</code>的时钟，这个和以往的<code>APB2/1</code>是不一样的。<code>DMA</code>是比较特殊的外设形式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DMA_InitTypeDef DMA_InitStructure;</span><br><span class="line">DMA_InitStructure.DMA_PeripheralBaseAddr = SAddr;</span><br><span class="line">DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;</span><br><span class="line">DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Enable;</span><br><span class="line"></span><br><span class="line">DMA_InitStructure.DMA_MemoryBaseAddr = DAddr;</span><br><span class="line">DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;</span><br><span class="line">DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;</span><br><span class="line"></span><br><span class="line">DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;</span><br><span class="line">DMA_InitStructure.DMA_BufferSize = size;</span><br><span class="line">DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;</span><br><span class="line">DMA_InitStructure.DMA_M2M = DMA_M2M_Enable;</span><br><span class="line">DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;</span><br><span class="line"></span><br><span class="line">DMA_Init(DMA1_Channel1,&amp;DMA_InitStructure);</span><br></pre></td></tr></table></figure>

<p>外设端<code>Peripheral</code>和存储器端<code>Memory</code>都需要配置3个参数<code>BaseAddr</code>，即基地址，作为转运的起点或终点。<code>DataSize</code>即数据宽度。<code>Inc</code>即地址是否自增。</p>
<p>基地址<code>BaseAddr</code>直接给数组的首地址就可以，由于这个地址并非预定义的，所以可以通过调用函数的时候传参。比如这里<code>DMA_PeripheralBaseAddr</code>外设端基地址就是<code>SAddr</code>起始地址，而存储端基地址<code>DMA_MemoryBaseAddr</code>就是<code>DAddr</code>。</p>
<p>数据宽度<code>DataSize</code>都选择字节<code>Byte</code>就可以。当数据宽度不一致时需要数据对齐，这里就不搞这个麻烦了。</p>
<p><code>Inc</code>配置为<code>ENABLE</code>来启用地址自增，因为数组元素不止一个，启用自增就可以转运完数组的一个元素后到下一个地址转运下一个元素，相当于指针的<code>p++</code>。这个和一轮转运完继续下一轮不一样，一轮转运可以包括<code>n</code>次转运，这个是一轮转运中的一次转运完再继续下一次。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;</span><br><span class="line">DMA_InitStructure.DMA_BufferSize = size;</span><br><span class="line">DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;</span><br><span class="line">DMA_InitStructure.DMA_M2M = DMA_M2M_Enable;</span><br><span class="line">DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;</span><br></pre></td></tr></table></figure>

<p>两端的三参数配置好后，剩下的五个参数就是<code>DMA</code>的其他配置。<code>DMA_DIR</code>指定了<code>DMA</code>的实际转运方向。前面在外设端设置了源地址，而存储器端设置了目的地地址，所以外设端是当做转运的起始的。在这里配置为<code>DMA_DIR_PeripheralSRC</code>，即<code>Peripheral</code>外设端作为<code>SRC</code>，转运起始。</p>
<p><code>BufferSize</code>即缓冲区大小，实际上经过底层操作之后就是相当于是传输计数器的值，表示一轮转运的转运次数。这也是为什么传参进来的变量是<code>size</code>而非<code>num</code>之类的了。</p>
<p><code>DMA_Mode</code>其实经过底层操作也是相当于自动重装的启用模式。这里的话，转运数组是<code>SRAM to SRAM</code>，用软件触发，自动重装与软件触发冲突了，不需要启用，写<code>DMA_Mode_Normal</code> 就行。</p>
<p><code>DMA_M2M</code>表示是否是<code>Memory to Memory</code>，是的话就启用软件触发，不然就是硬件触发。<code>DMA_M2M_Enable</code>就是启用了软件触发。</p>
<p><code>DMA_Priority</code>则是配置仲裁器的优先级。结构体配置不应用到整个<code>DMA</code>，而是一条通道上，所以这里是给当前通道配置仲裁器优先级的。</p>
<p>至此需要用结构体配置的参数都结束了，接下来开始初始化配置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DMA_Init(DMA1_Channel1,&amp;DMA_InitStructure);</span><br></pre></td></tr></table></figure>

<p>在启动初始化这里，才是选择<code>DMA</code>和通道的地方。<code>DMAx_Channely</code>中的<code>x,y</code>都可以指定来选择用哪个<code>DMA</code>和哪个通道。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DMA_Cmd(DMA1_Channel1,ENABLE);</span><br></pre></td></tr></table></figure>

<p> 最后再使能一遍，也要选。</p>
<h3 id="14-4-2-DMA-重新转运"><a href="#14-4-2-DMA-重新转运" class="headerlink" title="14.4.2 DMA 重新转运"></a>14.4.2 DMA 重新转运</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DMACfg_Retransfer</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	DMA_Cmd(DMA1_Channel1,DISABLE);</span><br><span class="line">	DMA_SetCurrDataCounter(DMA1_Channel1,DMA_reSize);</span><br><span class="line">	DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(DMA_GetFlagStatus(DMA1_FLAG_TC1) == RESET);</span><br><span class="line">	DMA_ClearFlag(DMA1_FLAG_TC1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>软件触发只是自动开始转运，转运结束之后传输计数值是<code>0</code>，而又禁用了自动重装，这里就可以手动重装一下。存储器到存储器使用软件触发是需求，所以想要多轮转运就必须自己来重装了。</p>
<p>一开始定义的静态全局变量<code>DMA_reSize</code>在此处就有了用武之地。重装传输计数器需要先关闭<code>DMA</code>再写传输计数器，这是硬性要求，所以在这里先失能<code>DMA</code>。</p>
<p>函数<code>DMA_SetCurrDataCounter</code>为<code>DMAx</code>的<code>y</code>通道传输计数器赋值，这里就对原来的通道赋值就可以。重装完之后再使能<code>DMA</code>即可。</p>
<p>最后需要等待当前<code>DMA</code>转运完成，才能开始下一轮转运，这个时候用<code>while</code>循环和函数<code>DMA_GetFlagStatus</code>来检测<code>DMA</code>转运的标志位。参数<code>DMA1_FLAG_TC1</code>表示所检测的标志位是<code>Transfer Complete</code>，转运完成的标志位。当转运未完成时，返回<code>RESET</code>，卡死循环。</p>
<p>转运完成后，清除标志位。</p>
<h3 id="14-4-3-主函数"><a href="#14-4-3-主函数" class="headerlink" title="14.4.3 主函数"></a>14.4.3 主函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PWM.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;IC.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DMACfg.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Data_Source[] =&#123;<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x03</span>,<span class="number">0x04</span>&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Data_Destination[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	OLED_Init();</span><br><span class="line">	</span><br><span class="line">	DMACfg_Init((<span class="type">unsigned</span> <span class="type">int</span>)Data_Source,(<span class="type">unsigned</span> <span class="type">int</span>)Data_Destination,<span class="number">4</span>);</span><br><span class="line">	</span><br><span class="line">	OLED_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;SData&quot;</span>);</span><br><span class="line">	OLED_ShowString(<span class="number">3</span>,<span class="number">1</span>,<span class="string">&quot;DData&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	OLED_ShowHexNum(<span class="number">1</span>,<span class="number">8</span>,(<span class="type">unsigned</span> <span class="type">int</span>)Data_Source,<span class="number">8</span>);</span><br><span class="line">	OLED_ShowHexNum(<span class="number">3</span>,<span class="number">8</span>,(<span class="type">unsigned</span> <span class="type">int</span>)Data_Destination,<span class="number">8</span>);</span><br><span class="line">	</span><br><span class="line">	OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,Data_Source[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">	OLED_ShowHexNum(<span class="number">2</span>,<span class="number">4</span>,Data_Source[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">	OLED_ShowHexNum(<span class="number">2</span>,<span class="number">7</span>,Data_Source[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">	OLED_ShowHexNum(<span class="number">2</span>,<span class="number">10</span>,Data_Source[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	OLED_ShowHexNum(<span class="number">4</span>,<span class="number">1</span>,Data_Destination[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">	OLED_ShowHexNum(<span class="number">4</span>,<span class="number">4</span>,Data_Destination[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">	OLED_ShowHexNum(<span class="number">4</span>,<span class="number">7</span>,Data_Destination[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">	OLED_ShowHexNum(<span class="number">4</span>,<span class="number">10</span>,Data_Destination[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)        </span><br><span class="line">  &#123;</span><br><span class="line">		Data_Source[<span class="number">0</span>]++;</span><br><span class="line">		Data_Source[<span class="number">1</span>]++;</span><br><span class="line">		Data_Source[<span class="number">2</span>]++;</span><br><span class="line">		Data_Source[<span class="number">3</span>]++;</span><br><span class="line">		</span><br><span class="line">		OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,Data_Source[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">2</span>,<span class="number">4</span>,Data_Source[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">2</span>,<span class="number">7</span>,Data_Source[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">2</span>,<span class="number">10</span>,Data_Source[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">		OLED_ShowHexNum(<span class="number">4</span>,<span class="number">1</span>,Data_Destination[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">4</span>,<span class="number">4</span>,Data_Destination[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">4</span>,<span class="number">7</span>,Data_Destination[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">4</span>,<span class="number">10</span>,Data_Destination[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line">		</span><br><span class="line">		Delay_ms(<span class="number">1000</span>);</span><br><span class="line">		</span><br><span class="line">		DMACfg_Retransfer();</span><br><span class="line">		</span><br><span class="line">		OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,Data_Source[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">2</span>,<span class="number">4</span>,Data_Source[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">2</span>,<span class="number">7</span>,Data_Source[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">2</span>,<span class="number">10</span>,Data_Source[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">		OLED_ShowHexNum(<span class="number">4</span>,<span class="number">1</span>,Data_Destination[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">4</span>,<span class="number">4</span>,Data_Destination[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">4</span>,<span class="number">7</span>,Data_Destination[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">4</span>,<span class="number">10</span>,Data_Destination[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line">		</span><br><span class="line">		Delay_ms(<span class="number">1000</span>);</span><br><span class="line">	</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DMACfg_Init((<span class="type">unsigned</span> <span class="type">int</span>)Data_Source,(<span class="type">unsigned</span> <span class="type">int</span>)Data_Destination,<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>数组声明的类型是<code>unsigned char</code>，所以传参时需要强制类型转换。数组的元素有<code>4</code>个，所以传输计数器的值应该给<code>4</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">OLED_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;SData&quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">3</span>,<span class="number">1</span>,<span class="string">&quot;DData&quot;</span>);</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">8</span>,(<span class="type">unsigned</span> <span class="type">int</span>)Data_Source,<span class="number">8</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>,<span class="number">8</span>,(<span class="type">unsigned</span> <span class="type">int</span>)Data_Destination,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,Data_Source[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">4</span>,Data_Source[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">7</span>,Data_Source[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">10</span>,Data_Source[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">1</span>,Data_Destination[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">4</span>,Data_Destination[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">7</span>,Data_Destination[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">10</span>,Data_Destination[<span class="number">3</span>],<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>两个<code>unsigned char</code>数组都是变量，所以可以强制类型转换为<code>unsigned int</code>来查看数组在<code>SRAM</code> 中的首地址。由于<code>Data_Source</code>是程序中第一个被声明的变量，所以预期其首地址是<code>SRAM</code> 开始的第一位，也就是<code>2000 0000</code>。</p>
<p>分别显示<code>Data_Source</code>和<code>Data_Destination</code>中的值，由于在上面初始化函数中已经使能了 <code>DMA</code>,数据已经成功被转运，所以此时两个的显示都应该是<code>01 02 03 04</code>.</p>
<p>为了使数据转运的过程更明显，可以在<code>while</code> 循环中进一步操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Data_Source[<span class="number">0</span>]++;</span><br><span class="line">Data_Source[<span class="number">1</span>]++;</span><br><span class="line">Data_Source[<span class="number">2</span>]++;</span><br><span class="line">Data_Source[<span class="number">3</span>]++;</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,Data_Source[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">4</span>,Data_Source[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">7</span>,Data_Source[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">10</span>,Data_Source[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">1</span>,Data_Destination[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">4</span>,Data_Destination[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">7</span>,Data_Destination[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">10</span>,Data_Destination[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Delay_ms(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">DMACfg_Retransfer();</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,Data_Source[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">4</span>,Data_Source[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">7</span>,Data_Source[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">10</span>,Data_Source[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">1</span>,Data_Destination[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">4</span>,Data_Destination[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">7</span>,Data_Destination[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">10</span>,Data_Destination[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Delay_ms(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>让源数组的每个元素自增，延时<code>1s</code> 后调用<code>DMACfg_Retransfer()</code>为传输计数器重装，软件触发自动开始下一轮转运。</p>
<p>这样子，<code>Data_Source</code>的值会先<code>Data_Destination</code>变化，隔<code>1s</code>之后数据才转运到目的数组中，体现这个转运的过程。当然转运完也要再延时<code>1s</code>，不然循环回到自增处，源数组的元素立刻自增了，不方便对比。</p>
<h2 id="14-5-Code-AD-多通道-配合-DMA"><a href="#14-5-Code-AD-多通道-配合-DMA" class="headerlink" title="14.5 Code: AD 多通道 配合 DMA"></a>14.5 Code: AD 多通道 配合 DMA</h2><h3 id="14-5-1-AD单次转换配合DMA单次转运"><a href="#14-5-1-AD单次转换配合DMA单次转运" class="headerlink" title="14.5.1 AD单次转换配合DMA单次转运"></a>14.5.1 AD单次转换配合DMA单次转运</h3><p><code>AD</code>多通道配合<code>DMA</code>的第一种配置方法是<code>ADC</code>进行单次转换,<code>DMA</code>也进行单次转运，直到四个通道都完成操作。由于此时可选择<code>ADC</code>转换完成后发送请求的<code>DMA</code>硬件触发，所以就不会像软件触发那样自动清空传输计数器了。<code>ADC</code>方面选择单次转换扫描模式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> AD_Value[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADConvert_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);</span><br><span class="line">	</span><br><span class="line">	RCC_ADCCLKConfig(RCC_PCLK2_Div6);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	ADC_RegularChannelConfig(ADC1,ADC_Channel_0,<span class="number">1</span>,ADC_SampleTime_55Cycles5);</span><br><span class="line">	ADC_RegularChannelConfig(ADC1,ADC_Channel_1,<span class="number">2</span>,ADC_SampleTime_55Cycles5);</span><br><span class="line">	ADC_RegularChannelConfig(ADC1,ADC_Channel_2,<span class="number">3</span>,ADC_SampleTime_55Cycles5);</span><br><span class="line">	ADC_RegularChannelConfig(ADC1,ADC_Channel_3,<span class="number">4</span>,ADC_SampleTime_55Cycles5);</span><br><span class="line">	</span><br><span class="line">	ADC_InitTypeDef ADC_InitStructure;</span><br><span class="line">	ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;</span><br><span class="line">	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;</span><br><span class="line">	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;</span><br><span class="line">	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;</span><br><span class="line">	ADC_InitStructure.ADC_NbrOfChannel = <span class="number">4</span>;</span><br><span class="line">	ADC_InitStructure.ADC_ScanConvMode = ENABLE;</span><br><span class="line">	</span><br><span class="line">	ADC_Init(ADC1,&amp;ADC_InitStructure);</span><br><span class="line">	</span><br><span class="line">	DMA_InitTypeDef DMA_InitStructure;</span><br><span class="line">	DMA_InitStructure.DMA_PeripheralBaseAddr = (<span class="type">unsigned</span> <span class="type">int</span>)&amp;ADC1-&gt;DR;</span><br><span class="line">	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;</span><br><span class="line">	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;</span><br><span class="line">	</span><br><span class="line">	DMA_InitStructure.DMA_MemoryBaseAddr = (<span class="type">unsigned</span> <span class="type">int</span>)AD_Value;</span><br><span class="line">	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;</span><br><span class="line">	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;</span><br><span class="line">	</span><br><span class="line">	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;</span><br><span class="line">	DMA_InitStructure.DMA_BufferSize = <span class="number">4</span>;</span><br><span class="line">	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;</span><br><span class="line">	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;</span><br><span class="line">	DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;</span><br><span class="line">	</span><br><span class="line">	DMA_Init(DMA1_Channel1,&amp;DMA_InitStructure);</span><br><span class="line">	</span><br><span class="line">	DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line">	</span><br><span class="line">	ADC_DMACmd(ADC1,ENABLE);</span><br><span class="line">	</span><br><span class="line">	ADC_Cmd(ADC1,ENABLE);</span><br><span class="line">	</span><br><span class="line">	ADC_ResetCalibration(ADC1);</span><br><span class="line">	<span class="keyword">while</span>(ADC_GetResetCalibrationStatus(ADC1) == SET);</span><br><span class="line">	ADC_StartCalibration(ADC1);</span><br><span class="line">	<span class="keyword">while</span>(ADC_GetCalibrationStatus(ADC1) == SET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Get_ADCValue</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	DMA_Cmd(DMA1_Channel1,DISABLE);</span><br><span class="line">	DMA_SetCurrDataCounter(DMA1_Channel1,<span class="number">4</span>);</span><br><span class="line">	DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line">	</span><br><span class="line">	ADC_SoftwareStartConvCmd(ADC1,ENABLE);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(DMA_GetFlagStatus(DMA1_FLAG_TC1) == RESET);</span><br><span class="line">	DMA_ClearFlag(DMA1_FLAG_TC1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> AD_Value[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<p>有别于原来的伪<code>AD</code>多通道，这里直接将<code>AD</code>多通道每个通道转换出来的值用<code>DMA</code>转运到数组当中，在初始化文件中可以先声明，然后在头文件中引出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);</span><br></pre></td></tr></table></figure>

<p>与原来相比，开启时钟需要把<code>AHB</code>总线时钟也打开以启用<code>DMA</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_0,<span class="number">1</span>,ADC_SampleTime_55Cycles5);</span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_1,<span class="number">2</span>,ADC_SampleTime_55Cycles5);</span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_2,<span class="number">3</span>,ADC_SampleTime_55Cycles5);</span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_3,<span class="number">4</span>,ADC_SampleTime_55Cycles5);</span><br></pre></td></tr></table></figure>

<p>在配置完<code>GPIO</code>后由于多通道并不像伪多通道那样需要传参来决定<code>ADC_Channe</code>，而是一开始在初始化里就配置好多条通道的。所以这里通道选择函数<code>ADC_RegularChannelConfig</code>就放在初始化里面了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ADC_InitTypeDef ADC_InitStructure;</span><br><span class="line">ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;</span><br><span class="line">ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;</span><br><span class="line">ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;</span><br><span class="line">ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;</span><br><span class="line">ADC_InitStructure.ADC_NbrOfChannel = <span class="number">4</span>;</span><br><span class="line">ADC_InitStructure.ADC_ScanConvMode = ENABLE;</span><br><span class="line"></span><br><span class="line">ADC_Init(ADC1,&amp;ADC_InitStructure);</span><br></pre></td></tr></table></figure>

<p><code>ADC</code>结构体配置方面只需要稍作更改。多通道模式下，本次仍然选择单次转换，无需更改连续模式。唯二需要更改的参数是<code>ADC_NbrOfChannel</code>,改成通道数量<code>4</code>,<code>ADC_InitStructure.ADC_ScanConvMode</code>写<code>ENABLE</code>启用扫描模式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DMA_InitTypeDef DMA_InitStructure;</span><br><span class="line">DMA_InitStructure.DMA_PeripheralBaseAddr = (<span class="type">unsigned</span> <span class="type">int</span>)&amp;ADC1-&gt;DR;</span><br><span class="line">DMA_InitStructure.DMA_PeripheralDataSize =                                  DMA_PeripheralDataSize_HalfWord;</span><br><span class="line">DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;</span><br><span class="line"></span><br><span class="line">DMA_InitStructure.DMA_MemoryBaseAddr = (<span class="type">unsigned</span> <span class="type">int</span>)AD_Value;</span><br><span class="line">DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;</span><br><span class="line">DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;</span><br><span class="line"></span><br><span class="line">DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;</span><br><span class="line">DMA_InitStructure.DMA_BufferSize = <span class="number">4</span>;</span><br><span class="line">DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;</span><br><span class="line">DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;</span><br><span class="line">DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;</span><br><span class="line"></span><br><span class="line">DMA_Init(DMA1_Channel1,&amp;DMA_InitStructure);</span><br></pre></td></tr></table></figure>

<p>配置好<code>ADC</code>后再配置<code>DMA</code>的结构体。</p>
<p>外设端即<code>ADC</code>的数据寄存器。基地址是<code>ADC</code>的数据寄存器，表示为<code>ADC-&gt;DR (Data Register)</code>, 这里需要用<code>&amp;</code>取寄存器地址并且强制类型转换。由于<code>STM32F103C8T6</code>规则组只使用寄存器的低<code>16</code>位，而转运的数据是<code>32</code>位的，所以相当于是半字转运，这里需要配置成<code>DMA_PeripheralDataSize_HalfWord</code>,而由于<code>ADC</code>的数据寄存器地址是固定的，所以不需要像数组那样自增地址，自增地址位禁用即可。</p>
<p>存储器端即<code>SRAM</code>中的数组<code>AD_Value</code>，数组名本身就相当于数组的首地址，所以这里配置基地址的时候不需要取地址，直接强制类型转换就可以了。数据宽度与上面保持一致。而数组有多个元素，所以这里仍然要允许自增地址。</p>
<p>缓冲区大小给通道数<code>4</code>。<code>M2M</code> 由于现在是<code>ADC</code>数据寄存器到<code>SRAM</code>中的数组，所以不是<code>M2M</code>,禁用表示使用硬件触发，触发源就是<code>ADC1</code>。</p>
<p><code>DMA</code>还是用单通道来转运<code>ADC</code>的数据。初始化选择<code>DMA_Channel1</code>。这里注意<code>DMA</code>的通道选取不是任意的，因为只有通道<code>1</code>才能接受来自<code>ADC1</code> 的<code>DMA</code>请求。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line"></span><br><span class="line">ADC_DMACmd(ADC1,ENABLE);</span><br><span class="line"></span><br><span class="line">ADC_Cmd(ADC1,ENABLE);</span><br><span class="line"></span><br><span class="line">ADC_ResetCalibration(ADC1);</span><br><span class="line"><span class="keyword">while</span>(ADC_GetResetCalibrationStatus(ADC1) == SET);</span><br><span class="line">ADC_StartCalibration(ADC1);</span><br><span class="line"><span class="keyword">while</span>(ADC_GetCalibrationStatus(ADC1) == SET);</span><br></pre></td></tr></table></figure>

<p><code>DMA</code>使能需要放在<code>ADC</code>之前。上面提到<code>DMA</code>现在是由硬件触发源来触发的，所以需要调用<code>ADC</code>硬件触发函数<code>ADC_DMACmd(ADC1,ENABLE)</code>,参数代表具体的<code>ADC</code>。</p>
<p>然后使能<code>ADC</code>并且进行校准。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Get_ADCValue</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	DMA_Cmd(DMA1_Channel1,DISABLE);</span><br><span class="line">	DMA_SetCurrDataCounter(DMA1_Channel1,<span class="number">4</span>);</span><br><span class="line">	DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line">	</span><br><span class="line">	ADC_SoftwareStartConvCmd(ADC1,ENABLE);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(DMA_GetFlagStatus(DMA1_FLAG_TC1) == RESET);</span><br><span class="line">	DMA_ClearFlag(DMA1_FLAG_TC1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对返回值函数也略作修改，相比之前的<code>AD</code>返回函数,需要删掉通道选择函数（因为在初始化已经选择多通道了），又因为<code>DMA</code>转运数据的时候<code>ADC</code>肯定也已经转换完成了，所以这里就需要</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ADC.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">		ADConvert_Init();</span><br><span class="line">		OLED_Init();</span><br><span class="line">		OLED_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;AD1:&quot;</span>);</span><br><span class="line">		OLED_ShowString(<span class="number">2</span>,<span class="number">1</span>,<span class="string">&quot;AD2:&quot;</span>);</span><br><span class="line">		OLED_ShowString(<span class="number">3</span>,<span class="number">1</span>,<span class="string">&quot;AD3:&quot;</span>);</span><br><span class="line">		OLED_ShowString(<span class="number">4</span>,<span class="number">1</span>,<span class="string">&quot;AD4:&quot;</span>);</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">			Get_ADCValue();</span><br><span class="line">			</span><br><span class="line">			OLED_ShowNum(<span class="number">1</span>,<span class="number">5</span>,AD_Value[<span class="number">0</span>],<span class="number">4</span>);</span><br><span class="line">			OLED_ShowNum(<span class="number">2</span>,<span class="number">5</span>,AD_Value[<span class="number">1</span>],<span class="number">4</span>);</span><br><span class="line">			OLED_ShowNum(<span class="number">3</span>,<span class="number">5</span>,AD_Value[<span class="number">2</span>],<span class="number">4</span>);</span><br><span class="line">			OLED_ShowNum(<span class="number">4</span>,<span class="number">5</span>,AD_Value[<span class="number">3</span>],<span class="number">4</span>);</span><br><span class="line">			Delay_ms(<span class="number">100</span>);</span><br><span class="line">		&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数调用一次<code>Get_Value()</code>就可以转换四个通道并将转换值用<code>DMA</code>转运到数组里了，然后直接用<code>OLED</code>显示即可。</p>
<h3 id="14-5-2-AD连续转换配合DMA循环转运"><a href="#14-5-2-AD连续转换配合DMA循环转运" class="headerlink" title="14.5.2 AD连续转换配合DMA循环转运"></a>14.5.2 AD连续转换配合DMA循环转运</h3><p>这种情况下,只需要一次软件触发就可以让<code>ADC</code>连续转换。而在循环转运模式下，自动重装器被启用，<code>DMA</code>自动重装传输计数器（当然前提是使用硬件触发）。</p>
<p>代码只需要小部分修改：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;</span><br></pre></td></tr></table></figure>

<p>启用<code>ADC</code>连续转换模式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;</span><br></pre></td></tr></table></figure>

<p>启用<code>DMA</code>循环转运模式，使用自动重装器。</p>
<p>将<code>Get_ADValue</code>函数中的<code>ADC_SoftwareStartConvCmd(ADC1,ENABLE)</code>软件触发挪到初始化函数的校准后面。这是因为虽然<code>ADC</code>启用了连续转换，但是仍需要最开始的软件触发来开始。而<code>DMA</code>方面由于已经启用了自动重装，不需要手动给传输计数器赋值了。这时候将<code>Get_ADValue</code>函数整个删除，在主函数中也一并删除，因为不需要用它来重装了。</p>
<p>如此一来主函数里面只要初始化一次，其他什么都不用干,<code>ADC</code>和<code>DMA</code>就能够自动完成所有操作，只管显示数据就可以了。</p>
<h1 id="15-USART-串口通信"><a href="#15-USART-串口通信" class="headerlink" title="15. USART 串口通信"></a>15. USART 串口通信</h1><h2 id="15-1-串口通信"><a href="#15-1-串口通信" class="headerlink" title="15.1 串口通信"></a>15.1 串口通信</h2><p>串口是一种应用十分广泛的通讯接口，串口成本低、容易使用、通信线路简单，可实现两个设备的互相通信。</p>
<p>单片机的串口可以使单片机与单片机、单片机与电脑、单片机与各式各样的模块互相通信，极大地扩展了单片机的应用范围，增强了单片机系统的硬件实力。</p>
<h2 id="15-2-串口通信硬件电路"><a href="#15-2-串口通信硬件电路" class="headerlink" title="15.2 串口通信硬件电路"></a>15.2 串口通信硬件电路</h2><p>简单双向串口通信有两根通信线（发送端<code>TX (Transmit)</code>和接收端<code>RX (Receive)</code>）,<code>TX</code>与<code>RX</code>要交叉连接，当只需单向的数据传输时，可以只接一根通信线。<code>TX</code>和<code>RX</code>都是单端信号，其电平是相对<code>GND</code>的，所以通信双方设备的<code>GND</code>要求共地，必须进行连接。<code>VCC</code>在两个设备都有独立供电的情况则不用进行连接。</p>
<p>直接从控制器发出的信号一般都遵从<code>TTL</code>电平标准，当电平标准不一致时，需要加电平转换芯片才能进行正常的通信。</p>
<h2 id="15-3-串口电平标准"><a href="#15-3-串口电平标准" class="headerlink" title="15.3 串口电平标准"></a>15.3 串口电平标准</h2><p>电平标准是数据<code>1</code>和数据<code>0</code>的表达方式，是传输线缆中人为规定的电压与数据的对应关系，串口常用的电平标准有如下三种：</p>
<ul>
<li><p><code>TTL</code>电平：<code>+3.3V</code>或<code>+5V</code>表示<code>1</code>，<code>0V</code>表示<code>0</code>,该协议在一般的单片机设备等低压小型中最为常见，根据设备的供电情况<code>3v3</code>或者<code>5V</code>来决定逻辑电平<code>1</code>的表示。</p>
</li>
<li><p><code>RS232</code>电平：<code>-3~-15V</code>表示<code>1</code>，<code>+3~+15V</code>表示<code>0</code>，该协议一般用于大型机器静电干扰较大的场合，允许电平的波动范围较大。</p>
</li>
<li><p><code>RS485</code>电平：两线压差<code>+2~+6V</code>表示<code>1</code>，<code>-2~-6V</code>表示<code>0</code>（差分信号），差分信号的电平基于两线压差，抗干扰能力强，传输距离能达到上千米，而上面的两种信号一般只能传输几十米的距离。</p>
</li>
</ul>
<h2 id="15-4-串口参数以及时序"><a href="#15-4-串口参数以及时序" class="headerlink" title="15.4 串口参数以及时序"></a>15.4 串口参数以及时序</h2><ul>
<li>波特率：串口通信的速率</li>
<li>起始位：标志一个数据帧的开始，固定为低电平</li>
<li>数据位：数据帧的有效载荷，<code>1</code>为高电平，<code>0</code>为低电平，低位先行</li>
<li>校验位：用于数据验证，根据数据位计算得来</li>
<li>停止位：用于数据帧间隔，固定为高电平</li>
</ul>
<p>在串口中，每一个字节都装载在数据帧内，而一个数据帧的组成部分是起始位、数据位和停止位。数据位一共有<code>8</code>位，而起始位和停止位各占<code>1</code>位，一个数据帧总共就有<code>10</code>位。</p>
<p>有时候可以在数据帧的数据位后再加一位奇偶校验位。</p>
<p>串口一般使用的是异步通信，所以通信的双方需要约定一个通信速率，这个通信速率就是波特率。波特率代表每秒传输码元的数目，单位为波特 (<code>Baud</code>)。除了波特率以外，比特率也表示一种数据传输的速率，比特率代表每秒传输的比特 (<code>bit</code>) 数目，单位为<code>bit/s or bps</code>。在二进制调制下，一个码元就相当于一个一个比特，此时波特率和比特率等价。单片机设备的通信一般都是使用二进制调制的，高电平为<code>1</code>，低电平为<code>0</code>，一比特就是一位。</p>
<p>当串口在空闲时引脚需要置高电平，因为起始位规定为低电平。当需要开始传输数据的时候，必须先发送一个起始位，即低电平。接收设备检测到了这个从空闲状态到起始位的下降沿，就表征这一帧数据的开始。</p>
<p>一帧数据的结束则是停止位。停止位作为数据帧的间隔，规定为与起始位相反的高电平。</p>
<p>串口可以选择使用奇偶校验位对数据进行校验，一旦数据出错，可以选择丢弃或者重新进行传输。奇校验总是保证数据中有奇数个<code>1</code>，偶校验总是保证数据中有偶数个<code>1</code> 。发送方在发送数据之后会补一个校验位，接收方接收数据后会对数据位和校验位进行验证，如果<code>1</code><br>的个数仍然保持为奇数或偶数，那么就说明数据是没有问题的。</p>
<p>奇偶校验在两个位同时变化时可能会失效，因为两个位的变化可能会使得奇偶变化中和，奇偶性不变而数据位变化，这个时候奇偶校验就没有用了。</p>
<h2 id="15-4-USART"><a href="#15-4-USART" class="headerlink" title="15.4 USART"></a>15.4 USART</h2><p>USART（Universal Synchronous&#x2F;Asynchronous Receiver&#x2F;Transmitter）通用同步&#x2F;异步收发器是STM32内部集成的硬件外设，可根据数据寄存器的一个字节数据自动生成数据帧时序，从TX引脚发送出去，也可自动接收RX引脚的数据帧时序，拼接为一个字节数据，存放在数据寄存器里。</p>
<p>STM32上USART自带波特率发生器，最高达4.5Mbits&#x2F;s，可配置数据位长度（8&#x2F;9）、停止位长度（0.5&#x2F;1&#x2F;1.5&#x2F;2），可选校验位（无校验&#x2F;奇校验&#x2F;偶校验），支持同步模式、硬件流控制、DMA、智能卡、IrDA、LIN。</p>
<p>STM32F103C8T6上的USART资源： USART1、 USART2、 USART3。</p>
<p>一般使用异步模式，同步模式多出了额外的时钟输出，一般适用于兼容其他协议来使用的，并不支持两个USART之间的同步通信。</p>
<h2 id="15-5-Code-USART发送数据"><a href="#15-5-Code-USART发送数据" class="headerlink" title="15.5 Code: USART发送数据"></a>15.5 Code: USART发送数据</h2><h3 id="15-5-1-初始化-USART"><a href="#15-5-1-初始化-USART" class="headerlink" title="15.5.1 初始化 USART"></a>15.5.1 初始化 USART</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStruture;</span><br><span class="line">	GPIO_InitStruture.GPIO_Mode = GPIO_Mode_AF_PP; <span class="comment">//TXD - Alternate Push and Pull Out</span></span><br><span class="line">																								 <span class="comment">//Alternate: PA9 can be initialized in multiple port</span></span><br><span class="line">	GPIO_InitStruture.GPIO_Pin = GPIO_Pin_9;</span><br><span class="line">	GPIO_InitStruture.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitStruture);</span><br><span class="line">	</span><br><span class="line">	USART_InitTypeDef USART_InitStructure;</span><br><span class="line">	USART_InitStructure.USART_BaudRate = <span class="number">9600</span>;</span><br><span class="line">	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;</span><br><span class="line">	USART_InitStructure.USART_Mode = USART_Mode_Tx;</span><br><span class="line">	USART_InitStructure.USART_Parity = USART_Parity_No;</span><br><span class="line">	USART_InitStructure.USART_StopBits = USART_StopBits_1;</span><br><span class="line">	USART_InitStructure.USART_WordLength = USART_WordLength_8b;</span><br><span class="line">	USART_Init(USART1,&amp;USART_InitStructure);</span><br><span class="line">	</span><br><span class="line">	USART_Cmd(USART1,ENABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用结构体初始化的常规操作。<code>USART1</code>发送脚<code>TX</code>对应<code>GPIOA PIN9</code>,又因为这是一个复用端口，所以<code>GPIO</code>需要配置为复用推挽输出模式。</p>
<p>结构体参数如下：</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
<th>Status</th>
</tr>
</thead>
<tbody><tr>
<td><code>USART_BaudRate</code></td>
<td>配置<code>USART</code>波特率</td>
<td>可以直接写具体的波特率值，这里配置成常规的<code>9600</code></td>
</tr>
<tr>
<td><code>USART_HardwareFlowControl</code></td>
<td>配置<code>USART</code>硬件流控制</td>
<td>参数<code>USART_HardwareFlowControl_None</code>表示不启用硬件流控制，其它参数可分别控制为<code>RTS</code>和<code>CTS</code>单独或共同启用硬件流控制</td>
</tr>
<tr>
<td><code>USART_Mode</code></td>
<td>配置<code>USART</code>的模式</td>
<td>参数<code>USART_Mode_Tx</code>表示启用发送模式，如果需要启用收发模式，则需要写<code>USART_Mode_Tx|USART_Mode_Rx</code></td>
</tr>
<tr>
<td><code>USART_Parity</code></td>
<td>配置<code>USART</code>的校验位</td>
<td>参数<code>USART_Parity_No</code>表示不启用校验，其他有启用奇偶校验</td>
</tr>
<tr>
<td><code>USART_StopBits</code></td>
<td>配置<code>USART</code>的停止位</td>
<td>参数<code>USART_StopBits_1</code>表示停止位长度为<code>1</code>，常规情况下如此配置</td>
</tr>
<tr>
<td><code>USART_WordLength</code></td>
<td>配置<code>USART</code>数据帧的字长</td>
<td>参数<code>USART_WordLength_8b</code>为<code>8</code>位字长，开启校验位时则需要换至<code>9</code>位。</td>
</tr>
</tbody></table>
<h3 id="15-5-2-发送单个字节"><a href="#15-5-2-发送单个字节" class="headerlink" title="15.5.2 发送单个字节"></a>15.5.2 发送单个字节</h3>
  </div>
  
  
    
    <div class='footer'>
       <!-- 参考资料、相关资料等 -->
      
       <!-- 相关文章 -->
      
      <!-- 版权声明组件 -->
      
      <!-- 打赏组件 -->
      
    </div>
  
  
    


  <div class='article-meta' id="bottom">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateModified" datetime="2025-09-04T12:47:03+08:00">
  <a class='notlink'>
    <i class="fa-solid fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：2025年9月4日</p>
  </a>
</div>

        
      
        
          

        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://jav1ki4n.github.io/2024/06/14/STM32%20SPL%20Based%20Note%20By%20Ian%20Jav%C3%ADk/&title=STM32 SPL Based Note By Ian Javík - i4N's Terminal&summary="
          
          >
          
            <img src="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/qq.png" class="lazyload" data-srcset="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/qq.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://jav1ki4n.github.io/2024/06/14/STM32%20SPL%20Based%20Note%20By%20Ian%20Jav%C3%ADk/&title=STM32 SPL Based Note By Ian Javík - i4N's Terminal&summary="
          
          >
          
            <img src="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/qzone.png" class="lazyload" data-srcset="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/qzone.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="http://service.weibo.com/share/share.php?url=http://jav1ki4n.github.io/2024/06/14/STM32%20SPL%20Based%20Note%20By%20Ian%20Jav%C3%ADk/&title=STM32 SPL Based Note By Ian Javík - i4N's Terminal&summary="
          
          >
          
            <img src="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/weibo.png" class="lazyload" data-srcset="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/weibo.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">
          
        </a>
      
    
      
    
      
    
  </div>
</div>



        
      
    </div>
    <!-- Custom Files bottomMeta begin -->
    
    <!-- Custom Files bottomMeta end -->
  </div>


  
  

  
    <div class="prev-next">
      
        <a class='prev' href='/2025/09/04/hello-world/'>
          <p class='title'><i class="fa-solid fa-chevron-left" aria-hidden="true"></i>Hello World</p>
          <p class='content'>Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any ...</p>
        </a>
      
      
    </div>
  
  <!-- Custom Files postEnd begin-->
  
  <!-- Custom Files postEnd end-->
</article>


  


  <article class="post white-box shadow floatable blur" id="comments">
    <span hidden>
      <meta itemprop="discussionUrl" content="/2024/06/14/STM32%20SPL%20Based%20Note%20By%20Ian%20Jav%C3%ADk/index.html#comments">
    </span>
    <p ct><i class='fa-solid fa-comments'></i> 评论</p>
    

    <div id="layoutHelper-comments"></div>

  </article>






</div>
<aside id='l_side' itemscope itemtype="http://schema.org/WPSideBar">
  

  
    
    
      
    
  


<div class="widget-sticky pjax">

  
  


  <section class="widget toc-wrapper desktop mobile " id="toc-div" >
    
  <header>
    
      <i class="fa-solid fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-SWD-%E8%B0%83%E8%AF%95%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%B8%8B%E8%BD%BD"><span class="toc-text">1.1 SWD 调试接口：下载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-PC13-%E5%BC%95%E8%84%9A%EF%BC%9A%E6%9D%BF%E8%BD%BDLED"><span class="toc-text">1.2  PC13 引脚：板载LED</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-PWR-%E5%BC%95%E8%84%9A-LED%EF%BC%9A%E7%94%B5%E6%BA%90%E7%8A%B6%E6%80%81%E6%8C%87%E7%A4%BA"><span class="toc-text">1.3 PWR 引脚 - LED：电源状态指示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-BOOT-%E5%BC%95%E8%84%9A%EF%BC%9A%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%E9%80%89%E6%8B%A9"><span class="toc-text">1.4 BOOT 引脚：启动模式选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-APB2%E6%97%B6%E9%92%9F%E4%BD%BF%E8%83%BD%E5%87%BD%E6%95%B0"><span class="toc-text">4.1 APB2时钟使能函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="toc-text">4.1.1 函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-%E5%8F%82%E6%95%B0%E8%A7%A3%E9%87%8A"><span class="toc-text">4.1.2 参数解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-GPIO%E9%85%8D%E7%BD%AE%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BF%A1%E6%81%AF"><span class="toc-text">4.2 GPIO配置初始化信息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E5%A3%B0%E6%98%8E%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F"><span class="toc-text">4.2.1 声明结构体变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">4.2.2 初始化结构体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E5%88%9D%E5%A7%8B%E5%8C%96GPIO"><span class="toc-text">4.3 初始化GPIO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-GPIO%E8%BE%93%E5%87%BA%E6%95%B0%E6%8D%AE"><span class="toc-text">4.4 GPIO输出数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E6%80%BB%E7%BB%93"><span class="toc-text">4.5 总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E4%BB%80%E4%B9%88%E6%98%AFGPIO"><span class="toc-text">5.1 什么是GPIO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-GPIO%E7%89%B9%E5%BE%81"><span class="toc-text">5.2 GPIO特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E8%BE%93%E5%87%BA%E6%A8%A1%E5%BC%8F"><span class="toc-text">5.3 输出模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-1-%E6%8E%A8%E6%8C%BD%E8%BE%93%E5%87%BA-%EF%BC%88%E5%BC%BA%E8%BE%93%E5%87%BA%EF%BC%89"><span class="toc-text">5.3.1 推挽输出 （强输出）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-2-%E5%BC%80%E6%BC%8F%E8%BE%93%E5%87%BA"><span class="toc-text">5.3.2 开漏输出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-GPIO%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-text">5.4 GPIO的工作模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-GPIO-SetBits-ResetBits"><span class="toc-text">6.1 GPIO_SetBits &#x2F; ResetBits</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-GPIO-WriteBit"><span class="toc-text">6.2 GPIO_WriteBit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E5%90%8C%E6%97%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%9A%E4%B8%AA%E5%BC%95%E8%84%9A"><span class="toc-text">7.1 同时初始化多个引脚</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-GPIO-Write"><span class="toc-text">7.2 GPIO_Write</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-%E5%BE%AA%E7%8E%AF%E7%A7%BB%E4%BD%8D%E6%8E%A7%E5%88%B6%E5%BC%95%E8%84%9A%E7%8A%B6%E6%80%81"><span class="toc-text">7.4 循环移位控制引脚状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-GPIO-%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F"><span class="toc-text">8.1 GPIO 输入模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-1-%E4%B8%8A%E6%8B%89%E8%BE%93%E5%85%A5"><span class="toc-text">8.1.1 上拉输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-2-%E4%B8%8B%E6%8B%89%E8%BE%93%E5%85%A5"><span class="toc-text">8.1.2 下拉输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-3-%E5%85%B6%E4%BB%96%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F"><span class="toc-text">8.1.3 其他输入模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E9%A2%84%E6%9C%9F%E5%8A%9F%E8%83%BD"><span class="toc-text">8.2 预期功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E4%B8%BB%E5%87%BD%E6%95%B0"><span class="toc-text">8.3 主函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-text">8.4 相关函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-1-Key-Set-GPIO-%E8%BE%93%E5%85%A5%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">8.4.1 Key_Set - GPIO 输入初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-2-Key-Logic-GPIO-%E8%AF%BB%E5%8F%96%E5%87%BD%E6%95%B0"><span class="toc-text">8.4.2 Key_Logic - GPIO 读取函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E9%85%8D%E7%BD%AE-GPIO-%E5%8F%8A-AFIO-%E4%B8%AD%E6%96%AD%E6%BA%90%E9%80%89%E5%8F%96"><span class="toc-text">9.1 配置 GPIO 及 AFIO - 中断源选取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E9%85%8D%E7%BD%AE-EXTI-%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E4%BF%A1%E6%81%AF"><span class="toc-text">9.2 配置 EXTI - 外部中断信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-%E9%85%8D%E7%BD%AE-NVIC-%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">9.3 配置 NVIC - 中断优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-%E9%85%8D%E7%BD%AE-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-text">9.4 配置 中断处理函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-5-%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-text">9.5 相关函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Extra%EF%BC%9A%E5%85%83%E4%BB%B6%E8%A1%A8"><span class="toc-text">Extra：元件表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%88Timer%EF%BC%89"><span class="toc-text">10.1 定时器（Timer）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%AD%E6%96%AD%E8%BF%87%E7%A8%8B"><span class="toc-text">10.2 定时器中断过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-1-%E6%97%B6%E9%92%9F%E6%BA%90"><span class="toc-text">10.2.1 时钟源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-2-%E6%97%B6%E5%9F%BA%E5%8D%95%E5%85%83"><span class="toc-text">10.2.2 时基单元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-3-%E4%B8%AD%E6%96%AD%E8%BE%93%E5%87%BA%E6%8E%A7%E5%88%B6%E4%B8%8E-NVIC"><span class="toc-text">10.2.3 中断输出控制与 NVIC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%AD%E6%96%AD-RCC-%E5%86%85%E9%83%A8%E6%97%B6%E9%92%9F"><span class="toc-text">10.3 定时器中断 - RCC 内部时钟</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1-PWM"><span class="toc-text">11.1 PWM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-1-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">11.1.1 工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-2-%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-text">11.1.2 应用示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-OC%EF%BC%88Output-Compare%EF%BC%89%E8%BE%93%E5%87%BA%E6%AF%94%E8%BE%83"><span class="toc-text">11.2 OC（Output Compare）输出比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3-%E4%BD%BF%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E8%BE%93%E5%87%BAPWM%E6%B3%A2-%E5%91%BC%E5%90%B8%E7%81%AF"><span class="toc-text">11.3 使用定时器输出PWM波 - 呼吸灯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-1-GPIO-%E9%85%8D%E7%BD%AE"><span class="toc-text">11.3.1 GPIO 配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-2-TIM-%E9%85%8D%E7%BD%AE"><span class="toc-text">11.3.2 TIM 配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-3-OC-%E9%85%8D%E7%BD%AE"><span class="toc-text">11.3.3 OC 配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-4-%E8%AE%BE%E7%BD%AE-PWM-%E5%8F%82%E6%95%B0"><span class="toc-text">11.3.4 设置 PWM 参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-4-%E9%A9%B1%E5%8A%A8%E8%88%B5%E6%9C%BA"><span class="toc-text">11.4 驱动舵机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4-1-%E8%88%B5%E6%9C%BA%E8%A1%8C%E4%B8%BA"><span class="toc-text">11.4.1 舵机行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4-2-%E6%A1%A3%E4%BD%8D%E8%B0%83%E8%8A%82"><span class="toc-text">11.4.2 档位调节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-5-%E9%80%8F%E8%BF%87-TB6612-%E9%A9%B1%E5%8A%A8%E7%9B%B4%E6%B5%81%E7%94%B5%E6%9C%BA"><span class="toc-text">11.5 透过 TB6612 驱动直流电机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-1-IC-%E6%A8%A1%E5%BC%8F%EF%BC%9A%E6%B5%8B%E9%87%8F-PWM-%E7%9A%84%E9%A2%91%E7%8E%87"><span class="toc-text">12.1 IC 模式：测量 PWM 的频率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-PWMI-%E6%A8%A1%E5%BC%8F%EF%BC%9A%E6%B5%8B%E9%87%8F-PWM-%E4%BF%A1%E5%8F%B7%E7%9A%84%E9%A2%91%E7%8E%87%E4%B8%8E%E5%8D%A0%E7%A9%BA%E6%AF%94"><span class="toc-text">12.2 PWMI 模式：测量 PWM 信号的频率与占空比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-3-TIM-%E7%BC%96%E7%A0%81%E5%99%A8%E6%8E%A5%E5%8F%A3"><span class="toc-text">12.3 TIM  编码器接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-1-%E7%BC%96%E7%A0%81%E5%99%A8%E6%8E%A5%E5%8F%A3%EF%BC%88Encoder-Interface%EF%BC%89"><span class="toc-text">12.3.1 编码器接口（Encoder Interface）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-2-%E6%AD%A3%E4%BA%A4%E7%BC%96%E7%A0%81%E5%99%A8"><span class="toc-text">12.3.2 正交编码器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%BC%96%E7%A0%81%E5%99%A8%E6%8E%A5%E5%8F%A3-%E7%BC%96%E7%A0%81%E5%99%A8%E6%B5%8B%E9%80%9F%E5%8E%9F%E7%90%86"><span class="toc-text">12.3.3 为什么使用编码器接口 &#x2F; 编码器测速原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-4-%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8"><span class="toc-text">12.3.4 实际应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-5-%E7%BC%96%E7%A0%81%E5%99%A8%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">12.3.5 编码器接口的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-6-%E7%BC%96%E7%A0%81%E5%99%A8%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-text">12.3.6 编码器接口的工作模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-7-Code-%E6%B5%8B%E9%87%8F%E7%BC%96%E7%A0%81%E5%99%A8%E9%80%9F%E5%BA%A6"><span class="toc-text">12.3.7 Code: 测量编码器速度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-1-ADC-%E6%A8%A1%E6%8B%9F-%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%E5%99%A8"><span class="toc-text">13.1 ADC 模拟 - 数字转换器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-2-%E4%B8%80%E8%88%AC-ADC-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">13.2 一般 ADC 工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-3-STM32%E4%B8%AD%E7%9A%84ADC"><span class="toc-text">13.3 STM32中的ADC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-1-%E8%BE%93%E5%85%A5%E9%80%9A%E9%81%93%E9%80%89%E5%8F%96"><span class="toc-text">13.3.1 输入通道选取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-4-%E5%BC%80%E5%A7%8B%E8%BD%AC%E6%8D%A2%E4%BF%A1%E5%8F%B7-ADC-%E6%97%B6%E9%92%9F"><span class="toc-text">13.3.4 开始转换信号 &#x2F; ADC 时钟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-5-%E6%95%B0%E6%8D%AE%E8%BE%93%E5%87%BA"><span class="toc-text">13.3.5 数据输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-6-%E5%85%B6%E4%BB%96"><span class="toc-text">13.3.6 其他</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-4-Code%EF%BC%9AAD%E5%8D%95%E9%80%9A%E9%81%93"><span class="toc-text">13.4 Code：AD单通道</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-4-1-%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%8E%9F%E7%90%86"><span class="toc-text">13.4.1 硬件电路配置及代码原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-4-2-ADC-Init-AD%E8%BD%AC%E6%8D%A2%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">13.4.2 ADC_Init - AD转换初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-4-4-%E8%8E%B7%E5%8F%96%E8%BD%AC%E6%8D%A2%E9%87%8F"><span class="toc-text">13.4.4 获取转换量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-4-5-%E4%B8%BB%E5%87%BD%E6%95%B0"><span class="toc-text">13.4.5 主函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-4-6-%E6%8B%93%E5%B1%95%EF%BC%9A%E5%90%AF%E7%94%A8%E8%BF%9E%E7%BB%AD%E8%BD%AC%E6%8D%A2"><span class="toc-text">13.4.6 拓展：启用连续转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-5-Code-%E4%BC%AAAD%E5%A4%9A%E9%80%9A%E9%81%93"><span class="toc-text">13.5 Code: 伪AD多通道</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-1-%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-text">14.1 存储器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-2-DMA-%E7%BB%93%E6%9E%84"><span class="toc-text">14.2 DMA 结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-3-DMA-%E5%8E%9F%E7%90%86"><span class="toc-text">14.3 DMA 原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-4-Code%EF%BC%9ADMA-%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8-%E6%95%B0%E7%BB%84%E5%80%BC%E8%BD%AC%E8%BF%90"><span class="toc-text">14.4 Code：DMA 存储器与存储器 - 数组值转运</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-1-DMA-%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="toc-text">14.4.1 DMA 启动配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-2-DMA-%E9%87%8D%E6%96%B0%E8%BD%AC%E8%BF%90"><span class="toc-text">14.4.2 DMA 重新转运</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-3-%E4%B8%BB%E5%87%BD%E6%95%B0"><span class="toc-text">14.4.3 主函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-5-Code-AD-%E5%A4%9A%E9%80%9A%E9%81%93-%E9%85%8D%E5%90%88-DMA"><span class="toc-text">14.5 Code: AD 多通道 配合 DMA</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-5-1-AD%E5%8D%95%E6%AC%A1%E8%BD%AC%E6%8D%A2%E9%85%8D%E5%90%88DMA%E5%8D%95%E6%AC%A1%E8%BD%AC%E8%BF%90"><span class="toc-text">14.5.1 AD单次转换配合DMA单次转运</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-5-2-AD%E8%BF%9E%E7%BB%AD%E8%BD%AC%E6%8D%A2%E9%85%8D%E5%90%88DMA%E5%BE%AA%E7%8E%AF%E8%BD%AC%E8%BF%90"><span class="toc-text">14.5.2 AD连续转换配合DMA循环转运</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-1-%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1"><span class="toc-text">15.1 串口通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-2-%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF"><span class="toc-text">15.2 串口通信硬件电路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-3-%E4%B8%B2%E5%8F%A3%E7%94%B5%E5%B9%B3%E6%A0%87%E5%87%86"><span class="toc-text">15.3 串口电平标准</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-4-%E4%B8%B2%E5%8F%A3%E5%8F%82%E6%95%B0%E4%BB%A5%E5%8F%8A%E6%97%B6%E5%BA%8F"><span class="toc-text">15.4 串口参数以及时序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-4-USART"><span class="toc-text">15.4 USART</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-5-Code-USART%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE"><span class="toc-text">15.5 Code: USART发送数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-5-1-%E5%88%9D%E5%A7%8B%E5%8C%96-USART"><span class="toc-text">15.5.1 初始化 USART</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-5-2-%E5%8F%91%E9%80%81%E5%8D%95%E4%B8%AA%E5%AD%97%E8%8A%82"><span class="toc-text">15.5.2 发送单个字节</span></a></li></ol></li></ol>
    </div>
  </section>

  

</div>


<!-- 没有 pjax 占位会报错 万恶的 pjax -->

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <!-- Custom Files side begin -->
  
  <!-- Custom Files side end -->
</aside>



          <!--此文件用来存放一些不方便取值的变量-->
<!--思路大概是将值藏到重加载的区域内-->

<pjax>
<script>
  window.pdata={}
  pdata.ispage=true;
  pdata.commentPath="";
  pdata.commentPlaceholder="";
  pdata.commentConfig={};
  //  see: /layout/_partial/scripts/_ctrl/coverCtrl.ejs
  
    // header
    var l_header=document.getElementById("l_header");
    
    l_header.classList.add("show");
    
    
      // cover
      var cover_wrapper=document.querySelector('#l_cover .cover-wrapper');
      var scroll_down=document.getElementById('scroll-down');
      cover_wrapper.id="none";
      cover_wrapper.style.display="none";
      scroll_down.style.display="none";
    
  
</script>
</pjax>
        </div>
        
  
  <footer class="footer clearfix"  itemscope itemtype="http://schema.org/WPFooter">
    <br><br>
    
      
        <div class="aplayer-container">
          


        </div>
      
    
      
        <br>
        <div class="social-wrapper" itemprop="about" itemscope itemtype="http://schema.org/Thing">
          
            
          
            
          
            
          
        </div>
      
    
      
        <div><p>博客内容遵循 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
      
    
      
        
          <div><p><span id="lc-sv">本站总访问量为 <span id='number'><i class="fa-solid fa-loader fa-spin fa-fw" aria-hidden="true"></i></span> 次</span> <span id="lc-uv">访客数为 <span id='number'><i class="fa-solid fa-loader fa-spin fa-fw" aria-hidden="true"></i></span> 人</span></p>
</div>
        
      
    
      
        本站使用
        <a href="https://github.com/volantis-x/hexo-theme-volantis/#5.8.0" target="_blank" class="codename">Volantis</a>
        作为主题
      
    
      
        <div class='copyright'>
        <p><a href="/">Copyright © since 2017 XXX</a></p>

        </div>
      
    
    <!-- Custom Files footer begin-->
    
    <!-- Custom Files footer end-->
  </footer>


        <a id="s-top" class="fa-solid fa-arrow-up fa-fw" href="/" onclick="return false;" title="top"></a>
      </div>
    </div>
    <div>
      <script>
  /******************** volantis.dom ********************************/
  // 页面选择器 将dom对象缓存起来 see: /source/js/app.js etc.
  volantis.dom.bodyAnchor = volantis.dom.$(document.getElementById("safearea")); // 页面主体
  volantis.dom.topBtn = volantis.dom.$(document.getElementById('s-top')); // 向上
  volantis.dom.wrapper = volantis.dom.$(document.getElementById('wrapper')); // 整个导航栏
  volantis.dom.coverAnchor = volantis.dom.$(document.querySelector('#l_cover .cover-wrapper')); // 1个
  volantis.dom.switcher = volantis.dom.$(document.querySelector('#l_header .switcher .s-search')); // 搜索按钮   移动端 1个
  volantis.dom.header = volantis.dom.$(document.getElementById('l_header')); // 移动端导航栏
  volantis.dom.search = volantis.dom.$(document.querySelector('#l_header .m_search')); // 搜索框 桌面端 移动端 1个
  volantis.dom.mPhoneList = volantis.dom.$(document.querySelectorAll('#l_header .m-phone .list-v')); //  手机端 子菜单 多个
</script>

<script>
  
  volantis.css("https://unpkg.com/volantis-static@0.0.1654736714924/libs/@fortawesome/fontawesome-free/css/all.min.css");
  
  
  
</script>

<!-- required -->


<!-- internal -->

<script src="/js/app.js"></script>






<!-- rightmenu要在darkmode之前（ToggleButton） darkmode要在comments之前（volantis.dark.push）-->



<script>
  function loadIssuesJS() {
    
      const sites_api = document.getElementById('sites-api');
      if (sites_api != undefined && typeof SitesJS === 'undefined') {
        volantis.js("/js/plugins/tags/sites.js")
      }
    
    
      const friends_api = document.getElementById('friends-api');
      if (friends_api != undefined && typeof FriendsJS === 'undefined') {
        volantis.js("/js/plugins/tags/friends.js")
      }
    
    
      const contributors_api = document.getElementById('contributors-api');
      if (contributors_api != undefined && typeof ContributorsJS === 'undefined') {
        volantis.js("/js/plugins/tags/contributors.js")
      }
    
  };
  loadIssuesJS()
  volantis.pjax.push(()=>{
    loadIssuesJS();
  })

</script>




  <script defer src="https://unpkg.com/volantis-static@0.0.1654736714924/libs/vanilla-lazyload/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 0
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    lazyLoadInstance.update();
  });
  document.addEventListener('pjax:complete', function () {
    lazyLoadInstance.update();
  });
</script>




  

<script>
  window.FPConfig = {
	delay: 0,
	ignoreKeywords: ["#"],
	maxRPS: 6,
	hoverDelay: 0
  };
</script>
<script defer src="https://unpkg.com/volantis-static@0.0.1654736714924/libs/flying-pages/flying-pages.min.js"></script>









      <script>
  volantis.layoutHelper("comments",`<div id="giscus_container"></div>`)

  volantis.giscus = {};

  function check_giscus() {
    if (volantis.dark.mode === "dark") {
      volantis.giscus.Theme = 'dark';
    } else {
      volantis.giscus.Theme = 'light';
    }

    return document.getElementById("giscus_container");
  }

  function pjax_giscus() {
    const HEAD = check_giscus();
    if (!HEAD) return;
    let cfg = Object.assign({"theme":{"light":"light","dark":"dark"}},pdata.commentConfig)
    const script = document.createElement('script');
    script.setAttribute('src', 'https://giscus.app/client.js');
    Object.keys(cfg).forEach(k=>{
      if (k != "theme") {
        script.setAttribute('data-'+k, cfg[k]);
      }
    })
    script.setAttribute('data-theme', volantis.giscus.Theme);
    script.setAttribute('crossorigin', "anonymous");
    HEAD.appendChild(script);
  }

  function dark_giscus() {
    const HEAD = check_giscus();
    if (!HEAD) return;

    const message = {
      setConfig: {
        theme: volantis.giscus.Theme
      }
    };
    const giscusIframe = document.querySelector('iframe.giscus-frame');
    giscusIframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
  }
  pjax_giscus();
  volantis.pjax.push(pjax_giscus);
  volantis.dark.push(dark_giscus);
</script>

    





<!-- optional -->

  <script>
  const SearchServiceDataPathRoot = ("/" || "/").endsWith("/") ?
    "/" || "/" :
    "//" || "/";
  const SearchServiceDataPath = SearchServiceDataPathRoot + "content.json";

  function loadSearchScript() {
    // see: layout/_partial/scripts/_ctrl/cdnCtrl.ejs
    return volantis.js("/js/search/hexo.js");
  }

  function loadSearchService() {
    loadSearchScript();
    document.querySelectorAll(".input.u-search-input").forEach((e) => {
      e.removeEventListener("focus", loadSearchService, false);
    });

    document.querySelectorAll(".u-search-form").forEach((e) => {
      e.addEventListener("submit", (event) => {
        event.preventDefault();
      }, false);
    });
  }

  // 打开并搜索 字符串 s
  function OpenSearch(s) {
    if (typeof SearchService === 'undefined')
      loadSearchScript().then(() => {
        SearchService.setQueryText(s);
        SearchService.search();
      });
    else {
      SearchService.setQueryText(s);
      SearchService.search();
    }
  }

  // 访问含有 ?s=xxx  的链接时打开搜索 // 与搜索引擎 structured data 相关: /scripts/helpers/structured-data/lib/config.js
  if (window.location.search && /^\?s=/g.test(window.location.search)) {
    let queryText = decodeURI(window.location.search)
      .replace(/\ /g, "-")
      .replace(/^\?s=/g, "");
    OpenSearch(queryText);
  }

  // 搜索输入框获取焦点时加载搜索
  document.querySelectorAll(".input.u-search-input").forEach((e) => {
    e.addEventListener("focus", loadSearchService, false);
  });
</script>







  <script>



  function pjax_highlightjs_copyCode(){
    if (!(document.querySelector(".highlight .code pre") ||
      document.querySelector(".article pre code"))) {
      return;
    }
    VolantisApp.utilCopyCode(".highlight .code pre, .article pre code")
  }
  volantis.requestAnimationFrame(pjax_highlightjs_copyCode)
  volantis.pjax.push(pjax_highlightjs_copyCode)

</script>












  <script>
  function load_swiper() {
    if (!document.querySelectorAll(".swiper-container")[0]) return;
    volantis.css("https://unpkg.com/volantis-static@0.0.1654736714924/libs/swiper/swiper-bundle.min.css");
    volantis.js("https://unpkg.com/volantis-static@0.0.1654736714924/libs/swiper/swiper-bundle.min.js").then(() => {
      pjax_swiper();
    });
  }

  load_swiper();

  function pjax_swiper() {
    volantis.swiper = new Swiper('.swiper-container', {
      slidesPerView: 'auto',
      spaceBetween: 8,
      centeredSlides: true,
      loop: true,
      pagination: {
        el: '.swiper-pagination',
        clickable: true,
      },
      navigation: {
        nextEl: '.swiper-button-next',
        prevEl: '.swiper-button-prev',
      },
    });
  }

  volantis.pjax.push(() => {
    if (!document.querySelectorAll(".swiper-container")[0]) return;
    if (typeof volantis.swiper === "undefined") {
      load_swiper();
    } else {
      pjax_swiper();
    }
  });
</script>


<!-- pjax 标签必须存在于所有页面 否则 pjax error -->
<pjax>

</pjax>

<script>
  function listennSidebarTOC() {
    const navItems = document.querySelectorAll(".toc li");
    if (!navItems.length) return;
    let targets = []
    const sections = [...navItems].map((element) => {
      const link = element.querySelector(".toc-link");
      const target = document.getElementById(
        decodeURI(link.getAttribute("href")).replace("#", "")
      );
      targets.push(target)
      // 解除 a 标签 href 的 锚点定位, a 标签 href 的 锚点定位 会随机启用?? 产生错位???
      link.setAttribute("onclick","return false;")
      link.setAttribute("toc-action","toc-"+decodeURI(link.getAttribute("href")).replace("#", ""))
      link.setAttribute("href","/")
      // 配置 点击 触发新的锚点定位
      link.addEventListener("click", (event) => {
        event.preventDefault();
        // 这里的 addTop 是通过错位使得 toc 自动展开.
        volantis.scroll.to(target,{addTop: 5, observer:true})
        // Anchor id
        history.pushState(null, document.title, "#" + target.id);
      });
      return target;
    });

    function activateNavByIndex(target) {
      if (target.classList.contains("active-current")) return;

      document.querySelectorAll(".toc .active").forEach((element) => {
        element.classList.remove("active", "active-current");
      });
      target.classList.add("active", "active-current");
      let parent = target.parentNode;
      while (!parent.matches(".toc")) {
        if (parent.matches("li")) parent.classList.add("active");
        parent = parent.parentNode;
      }
    }

    // 方案一：
    volantis.activateNavIndex=0
    activateNavByIndex(navItems[volantis.activateNavIndex])
    volantis.scroll.push(()=>{
      if (targets[0].getBoundingClientRect().top >= 0) {
        volantis.activateNavIndex = 0
      }else if (targets[targets.length-1].getBoundingClientRect().top < 0) {
        volantis.activateNavIndex = targets.length-1
      } else {
        for (let index = 0; index < targets.length; index++) {
          const target0 = targets[index];
          const target1 = targets[(index+1)%targets.length];
          if (target0.getBoundingClientRect().top < 0&&target1.getBoundingClientRect().top >= 0) {
            volantis.activateNavIndex=index
            break;
          }
        }
      }
      activateNavByIndex(navItems[volantis.activateNavIndex])
    })

    // 方案二：
    // IntersectionObserver 不是完美精确到像素级别 也不是低延时性的
    // function findIndex(entries) {
    //   let index = 0;
    //   let entry = entries[index];
    //   if (entry.boundingClientRect.top > 0) {
    //     index = sections.indexOf(entry.target);
    //     return index === 0 ? 0 : index - 1;
    //   }
    //   for (; index < entries.length; index++) {
    //     if (entries[index].boundingClientRect.top <= 0) {
    //       entry = entries[index];
    //     } else {
    //       return sections.indexOf(entry.target);
    //     }
    //   }
    //   return sections.indexOf(entry.target);
    // }
    // function createIntersectionObserver(marginTop) {
    //   marginTop = Math.floor(marginTop + 10000);
    //   let intersectionObserver = new IntersectionObserver(
    //     (entries, observe) => {
    //       let scrollHeight = document.documentElement.scrollHeight;
    //       if (scrollHeight > marginTop) {
    //         observe.disconnect();
    //         createIntersectionObserver(scrollHeight);
    //         return;
    //       }
    //       let index = findIndex(entries);
    //       activateNavByIndex(navItems[index]);
    //     }, {
    //       rootMargin: marginTop + "px 0px -100% 0px",
    //       threshold: 0,
    //     }
    //   );
    //   sections.forEach((element) => {
    //     element && intersectionObserver.observe(element);
    //   });
    // }
    // createIntersectionObserver(document.documentElement.scrollHeight);
  }

  document.addEventListener("DOMContentLoaded", ()=>{
    volantis.requestAnimationFrame(listennSidebarTOC)
  });
  document.addEventListener("pjax:success", ()=>{
    volantis.requestAnimationFrame(listennSidebarTOC)
  });
</script>



<script>
  document.onreadystatechange = function () {
    if (document.readyState == 'complete') {
      // 页面加载完毕 样式加载失败，或是当前网速慢，或是开启了省流模式
      const { saveData, effectiveType } = navigator.connection || navigator.mozConnection || navigator.webkitConnection || {}
      if (getComputedStyle(document.querySelector("#safearea"), null)["display"] == "none" || saveData || /2g/.test(effectiveType)) {
        document.querySelectorAll(".reveal").forEach(function (e) {
          e.style["opacity"] = "1";
        });
        document.querySelector("#safearea").style["display"] = "block";
      }
    }
  }
</script>


  <script type="application/ld+json">[{"@context":"http://schema.org","@type":"Organization","name":"i4N's Terminal","url":"http://Jav1ki4N.github.io/","logo":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}},{"@context":"http://schema.org","@type":"Person","name":"i4N","image":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png"},"url":"http://Jav1ki4N.github.io/","sameAs":["https://github.com/volantis-x"],"description":"666"},{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"http://Jav1ki4N.github.io/","name":"i4N's Terminal"}},{"@type":"ListItem","position":3,"item":{"@id":"http://Jav1ki4N.github.io/2024/06/14/STM32 SPL Based Note By Ian Javík/","name":"STM32 SPL Based Note By Ian Javík"}}]},{"@context":"http://schema.org","@type":"WebSite","name":"i4N's Terminal","url":"http://Jav1ki4N.github.io/","keywords":null,"description":"666","author":{"@type":"Person","name":"i4N","image":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png"},"url":"http://Jav1ki4N.github.io/","description":"666"},"publisher":{"@type":"Organization","name":"i4N's Terminal","url":"http://Jav1ki4N.github.io/","logo":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}},"potentialAction":{"@type":"SearchAction","name":"Site Search","target":{"@type":"EntryPoint","urlTemplate":"http://Jav1ki4N.github.io?s={search_term_string}"},"query-input":"required name=search_term_string"}},{"@context":"http://schema.org","@type":"BlogPosting","headline":"STM32 SPL Based Note By Ian Javík","description":"666","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"http://jav1ki4n.github.io/2024/06/14/STM32%20SPL%20Based%20Note%20By%20Ian%20Jav%C3%ADk/"},"author":{"@type":"Person","name":"i4N","image":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png"},"url":"http://Jav1ki4N.github.io/"},"publisher":{"@type":"Organization","name":"i4N's Terminal","logo":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}},"url":"http://jav1ki4n.github.io/2024/06/14/STM32%20SPL%20Based%20Note%20By%20Ian%20Jav%C3%ADk/","wordCount":0,"datePublished":"2024-06-13T16:00:00.000Z","dateModified":"2025-09-04T04:47:03.973Z","image":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}}]</script>



      
        <!--
  pjax重载区域接口：
  1.  <pjax></pjax> 标签 pjax 标签必须存在于所有页面 否则 pjax error
  2.  script[data-pjax]
  3.  .pjax-reload script
  4.  .pjax
-->



<script src="https://unpkg.com/volantis-static@0.0.1654736714924/libs/pjax/pjax.min.js"></script>


<script>
    var pjax;
    document.addEventListener('DOMContentLoaded', function () {
      pjax = new Pjax({
        elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([pjax-fancybox]):not([onclick="return false;"]):not([onclick="return!1"]):not([target="_blank"]):not([target="view_window"]):not([href$=".xml"])',
        selectors: [
          "head title",
          "head meta[name=keywords]",
          "head meta[name=description]",
          
          "#l_main",
          "#pjax-header-nav-list",
          ".pjax",
          "pjax", // <pjax></pjax> 标签
          "script[data-pjax], .pjax-reload script" // script标签添加data-pjax 或 script标签外层添加.pjax-reload 的script代码段重载
        ],
        cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
        timeout: 5000,
        
      });
    });

    document.addEventListener('pjax:send', function (e) {
      //window.stop(); // 相当于点击了浏览器的停止按钮

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      // 使用 volantis.pjax.send 方法传入pjax:send回调函数 参见layout/_partial/scripts/global.ejs
      volantis.pjax.method.send.start();
    });

    document.addEventListener('pjax:complete', function () {
      // 使用 volantis.pjax.push 方法传入重载函数 参见layout/_partial/scripts/global.ejs
      volantis.pjax.method.complete.start();
    });

    document.addEventListener('pjax:error', function (e) {
      if(volantis.debug) {
        console.error(e);
        console.log('pjax error: \n' + JSON.stringify(e));
      }else{
        // 使用 volantis.pjax.error 方法传入pjax:error回调函数 参见layout/_partial/scripts/global.ejs
        volantis.pjax.method.error.start();
        window.location.href = e.triggerElement.href;
      }
    });
</script>

      
    </div>
    <!-- import body_end begin-->
    <!-- import body_end end-->
    <!-- Custom Files bodyEnd begin-->
    
    <!-- Custom Files bodyEnd end-->
    <!-- front-matter body_end begin -->
    <!-- front-matter body_end end -->
  </body>
</html>
